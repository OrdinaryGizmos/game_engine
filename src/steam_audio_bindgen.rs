/* automatically generated by rust-bindgen 0.59.1 */
use bitflags::bitflags;

pub const STEAMAUDIO_VERSION_MAJOR: u32 = 4;
pub const STEAMAUDIO_VERSION_MINOR: u32 = 0;
pub const STEAMAUDIO_VERSION_PATCH: u32 = 0;
#[doc = " \\defgroup types Data Types"]
#[doc = "Common data types used throughout the Steam Audio API."]
#[doc = "\\{"]
pub type IPLint8 = ::std::os::raw::c_char;
pub type IPLuint8 = ::std::os::raw::c_uchar;
pub type IPLint16 = ::std::os::raw::c_short;
pub type IPLuint16 = ::std::os::raw::c_ushort;
pub type IPLint32 = ::std::os::raw::c_int;
pub type IPLuint32 = ::std::os::raw::c_uint;
pub type IPLint64 = ::std::os::raw::c_longlong;
pub type IPLuint64 = ::std::os::raw::c_ulonglong;
pub type IPLfloat32 = f32;
pub type IPLfloat64 = f64;
pub type IPLbyte = ::std::os::raw::c_uchar;
pub type IPLsize = usize;
pub type IPLstring = *const ::std::os::raw::c_char;
#[repr(i32)]
#[doc = " Boolean values."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IPLbool {
    #[doc = "< The Boolean value \\c false."]
    IPL_FALSE = 0,
    #[doc = "< The Boolean value \\c true."]
    IPL_TRUE = 1,
}
#[repr(i32)]
#[doc = " Status codes returned by Steam Audio API functions."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IPLerror {
    #[doc = "< The operation completed successfully."]
    IPL_STATUS_SUCCESS = 0,
    #[doc = "< An unspecified error occurred."]
    IPL_STATUS_FAILURE = 1,
    #[doc = "< The system ran out of memory."]
    IPL_STATUS_OUTOFMEMORY = 2,
    #[doc = "< An error occurred while initializing an external dependency."]
    IPL_STATUS_INITIALIZATION = 3,
}
#[doc = " Callback for updating the application on the progress of a function."]
#[doc = ""]
#[doc = "You can use this to provide the user with visual feedback, like a progress bar."]
#[doc = ""]
#[doc = "\\param  progress    Fraction of the function work that has been completed, between 0.0 and 1.0."]
#[doc = "\\param  userData    Pointer to arbitrary user-specified data provided when calling the function that will"]
#[doc = "call this callback."]
pub type IPLProgressCallback = ::std::option::Option<
    unsafe extern "C" fn(progress: IPLfloat32, userData: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IPLContext_t {
    _unused: [u8; 0],
}
pub type IPLContext = *mut _IPLContext_t;
#[repr(i32)]
#[doc = " Severity levels of log messages generated by Steam Audio."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IPLLogLevel {
    #[doc = "< A normal, informational message."]
    IPL_LOGLEVEL_INFO = 0,
    #[doc = "< A warning. The operation that generated this message may not work as expected."]
    IPL_LOGLEVEL_WARNING = 1,
    #[doc = "< An error. The operation that generated this message failed."]
    IPL_LOGLEVEL_ERROR = 2,
    #[doc = "< A detailed message intended for debugging purposes only."]
    IPL_LOGLEVEL_DEBUG = 3,
}
impl IPLSIMDLevel {
    pub const IPL_SIMDLEVEL_NEON: IPLSIMDLevel = IPLSIMDLevel::IPL_SIMDLEVEL_SSE2;
}
#[repr(i32)]
#[doc = " SIMD instruction sets that Steam Audio can attempt to use."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IPLSIMDLevel {
    #[doc = "< Intel Streaming SIMD Extensions 2. Up to 4 simultaneous floating-point operations."]
    IPL_SIMDLEVEL_SSE2 = 0,
    #[doc = "< Intel Streaming SIMD Extensions 4.2 or older. Up to 4 simultaneous floating-point operations."]
    IPL_SIMDLEVEL_SSE4 = 1,
    #[doc = "< Intel Advanced Vector Extensions or older. Up to 8 simultaneous floating-point operations."]
    IPL_SIMDLEVEL_AVX = 2,
    #[doc = "< Intel Advanced Vector Extensions 2 or older. Up to 8 simultaneous floating-point operations."]
    IPL_SIMDLEVEL_AVX2 = 3,
    #[doc = "< Intel Advanced Vector Extensions 512 or older. Up to 16 simultaneous floating-point operations."]
    IPL_SIMDLEVEL_AVX512 = 4,
}
#[doc = " Prototype of a callback that logs a message generated by Steam Audio. This may be implemented in any suitable way,"]
#[doc = "such as appending to a log file, displaying a dialog box, etc. The default behavior is to print to \\c stdout."]
#[doc = ""]
#[doc = "\\param  level       The severity level of the message."]
#[doc = "\\param  message     The message to log."]
pub type IPLLogFunction = ::std::option::Option<
    unsafe extern "C" fn(level: IPLLogLevel, message: *const ::std::os::raw::c_char),
>;
#[doc = " Prototype of a callback that allocates memory. This is usually specified to let Steam Audio use a custom memory"]
#[doc = "allocator. The default behavior is to use the OS-dependent aligned version of \\c malloc."]
#[doc = ""]
#[doc = "\\param  size        The number of bytes to allocate."]
#[doc = "\\param  alignment   The alignment (in bytes) of the start address of the allocated memory."]
#[doc = ""]
#[doc = "\\return Pointer to the allocated block of memory, or \\c NULL if allocation failed."]
pub type IPLAllocateFunction = ::std::option::Option<
    unsafe extern "C" fn(size: IPLsize, alignment: IPLsize) -> *mut ::std::os::raw::c_void,
>;
#[doc = " Prototype of a callback that frees a block of memory. This is usually specified when using a custom memory"]
#[doc = "allocator with Steam Audio. The default behavior is to use the OS-dependent aligned version of \\c free."]
#[doc = ""]
#[doc = "\\param  memoryBlock Pointer to the block of memory."]
pub type IPLFreeFunction =
    ::std::option::Option<unsafe extern "C" fn(memoryBlock: *mut ::std::os::raw::c_void)>;
#[doc = " Settings used to create a context object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLContextSettings {
    #[doc = " The API version used by the caller. Context creation will fail if `phonon.dll` does not implement a"]
    #[doc = "compatible version of the API. Typically, this should be set to `STEAMAUDIO_VERSION`."]
    pub version: IPLuint32,
    #[doc = " (Optional) If non-NULL, Steam Audio will call this function to record log messages generated by"]
    #[doc = "certain operations."]
    pub logCallback: IPLLogFunction,
    #[doc = " (Optional) If non-NULL, Steam Audio will call this function whenever it needs to allocate"]
    #[doc = "memory."]
    pub allocateCallback: IPLAllocateFunction,
    #[doc = " (Optional) If non-NULL, Steam Audio will call this function whenever it needs to free memory."]
    pub freeCallback: IPLFreeFunction,
    #[doc = " The maximum SIMD instruction set level that Steam Audio should use. Steam Audio automatically"]
    #[doc = "chooses the best instruction set to use based on the user's CPU, but you can prevent it from"]
    #[doc = "using certain newer instruction sets using this parameter. For example, with some workloads,"]
    #[doc = "AVX512 instructions consume enough power that the CPU clock speed will be throttled, resulting"]
    #[doc = "in lower performance than expected. If you observe this in your application, set this"]
    #[doc = "parameter to `IPL_SIMDLEVEL_AVX2` or lower."]
    pub simdLevel: IPLSIMDLevel,
}
extern "C" {
    #[doc = " Creates a context object. A context must be created before creating any other API objects."]
    #[doc = ""]
    #[doc = "\\param  settings    Pointer to the `IPLContextSettings` struct that specifies context creation parameters."]
    #[doc = "\\param  context     [out] Handle to the created context object."]
    #[doc = ""]
    #[doc = "\\return Status code indicating whether or not the operation succeeded."]
    pub fn iplContextCreate(
        settings: &IPLContextSettings,
        context: *mut IPLContext,
    ) -> IPLerror;
}
extern "C" {
    #[doc = " Retains an additional reference to a context. The context will not be destroyed until all references are"]
    #[doc = "released."]
    #[doc = ""]
    #[doc = "\\param  context     The context to retain a reference to."]
    #[doc = ""]
    #[doc = "\\return The additional reference to the context."]
    pub fn iplContextRetain(context: IPLContext) -> IPLContext;
}
extern "C" {
    #[doc = " Releases a reference to a context. The context will not be destroyed until all references are released."]
    #[doc = ""]
    #[doc = "\\param  context     [in, out] The context to release."]
    pub fn iplContextRelease(context: *mut IPLContext);
}
#[doc = " A point or vector in 3D space. Steam Audio uses a right-handed coordinate system, with the positive x-axis pointing"]
#[doc = "right, the positive y-axis pointing up, and the negative z-axis pointing ahead. Position and direction data"]
#[doc = "obtained from a game engine or audio engine must be properly transformed before being passed to any Steam Audio API"]
#[doc = "function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLVector3 {
    #[doc = " The x-coordinate."]
    pub x: IPLfloat32,
    #[doc = " The y-coordinate."]
    pub y: IPLfloat32,
    #[doc = " The z-coordinate."]
    pub z: IPLfloat32,
}
#[doc = " A 4x4 matrix used to represent an affine transform."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLMatrix4x4 {
    #[doc = " Matrix elements, in row-major order."]
    pub elements: [[IPLfloat32; 4usize]; 4usize],
}
#[doc = " An axis-aligned box. Axis-aligned boxes are used to specify a volume of 3D space."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLBox {
    #[doc = " The minimum coordinates of any vertex."]
    pub minCoordinates: IPLVector3,
    #[doc = " The maximum coordinates of any vertex."]
    pub maxCoordinates: IPLVector3,
}
#[doc = " A sphere. Spheres are used to define a region of influence around a point."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLSphere {
    #[doc = " The center."]
    pub center: IPLVector3,
    #[doc = " The radius."]
    pub radius: IPLfloat32,
}
#[doc = " A 3D coordinate system, expressed relative to a canonical coordinate system."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLCoordinateSpace3 {
    #[doc = " Unit vector pointing to the right (local +x axis)."]
    pub right: IPLVector3,
    #[doc = " Unit vector pointing upwards (local +y axis)."]
    pub up: IPLVector3,
    #[doc = " Unit vector pointing forwards (local -z axis)."]
    pub ahead: IPLVector3,
    #[doc = " The origin, relative to the canonical coordinate system."]
    pub origin: IPLVector3,
}
extern "C" {
    #[doc = " Calculates the relative direction from the listener to a sound source. The returned direction"]
    #[doc = "vector is expressed in the listener's coordinate system."]
    #[doc = ""]
    #[doc = "\\param  context             The context used to initialize Steam Audio."]
    #[doc = "\\param  sourcePosition      World-space coordinates of the source."]
    #[doc = "\\param  listenerPosition    World-space coordinates of the listener."]
    #[doc = "\\param  listenerAhead       World-space unit-length vector pointing ahead relative to the listener."]
    #[doc = "\\param  listenerUp          World-space unit-length vector pointing up relative to the listener."]
    #[doc = ""]
    #[doc = "\\return A unit-length vector in the listener's coordinate space, pointing from the listener to the source."]
    pub fn iplCalculateRelativeDirection(
        context: IPLContext,
        sourcePosition: IPLVector3,
        listenerPosition: IPLVector3,
        listenerAhead: IPLVector3,
        listenerUp: IPLVector3,
    ) -> IPLVector3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IPLSerializedObject_t {
    _unused: [u8; 0],
}
pub type IPLSerializedObject = *mut _IPLSerializedObject_t;
#[doc = " Settings used to create a serialized object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLSerializedObjectSettings {
    #[doc = " If non-NULL, the serialized object will contain the data in this buffer. If NULL,"]
    #[doc = "the serialized object will start out empty."]
    pub data: *mut IPLbyte,
    #[doc = " The number of bytes in the buffer pointed to by \\c data. Set to 0 if \\c data is"]
    #[doc = "NULL."]
    pub size: IPLsize,
}
extern "C" {
    #[doc = " Creates a serialized object."]
    #[doc = ""]
    #[doc = "\\param  context             The context used to initialize Steam Audio."]
    #[doc = "\\param  settings            The settings to use when creating the serialized object."]
    #[doc = "\\param  serializedObject    [out] The created serialized object."]
    #[doc = ""]
    #[doc = "\\return Status code indicating whether or not the operation succeeded."]
    pub fn iplSerializedObjectCreate(
        context: IPLContext,
        settings: *mut IPLSerializedObjectSettings,
        serializedObject: *mut IPLSerializedObject,
    ) -> IPLerror;
}
extern "C" {
    #[doc = " Retains an additional reference to a serialized object."]
    #[doc = ""]
    #[doc = "\\param  serializedObject    The serialized object to retain a reference to."]
    #[doc = ""]
    #[doc = "\\return The additional reference to the serialized object."]
    pub fn iplSerializedObjectRetain(serializedObject: IPLSerializedObject) -> IPLSerializedObject;
}
extern "C" {
    #[doc = " Releases a reference to a serialized object."]
    #[doc = ""]
    #[doc = "\\param  serializedObject    The serialized object to release a reference to."]
    pub fn iplSerializedObjectRelease(serializedObject: *mut IPLSerializedObject);
}
extern "C" {
    #[doc = " \\return The size in bytes of the serialized data contained in a serialized object."]
    #[doc = ""]
    #[doc = "\\param  serializedObject    The serialized object."]
    pub fn iplSerializedObjectGetSize(serializedObject: IPLSerializedObject) -> IPLsize;
}
extern "C" {
    #[doc = " \\return A pointer to a byte array of serialized data contained in a serialized object."]
    #[doc = ""]
    #[doc = "\\param  serializedObject    The serialized object."]
    pub fn iplSerializedObjectGetData(serializedObject: IPLSerializedObject) -> *mut IPLbyte;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IPLEmbreeDevice_t {
    _unused: [u8; 0],
}
pub type IPLEmbreeDevice = *mut _IPLEmbreeDevice_t;
#[doc = " Settings used to create an Embree device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLEmbreeDeviceSettings {
    pub _address: u8,
}
extern "C" {
    #[doc = " Creates an Embree device."]
    #[doc = ""]
    #[doc = "\\param  context     The context used to initialize Steam Audio."]
    #[doc = "\\param  settings    The settings to use when creating the Embree device."]
    #[doc = "\\param  device      [out] The created Embree device."]
    #[doc = ""]
    #[doc = "\\return Status code indicating whether or not the operation succeeded."]
    pub fn iplEmbreeDeviceCreate(
        context: IPLContext,
        settings: *mut IPLEmbreeDeviceSettings,
        device: *mut IPLEmbreeDevice,
    ) -> IPLerror;
}
extern "C" {
    #[doc = " Retains an additional reference to an Embree device."]
    #[doc = ""]
    #[doc = "\\param  device  The Embree device to retain a reference to."]
    #[doc = ""]
    #[doc = "\\return The additional reference to the Embree device."]
    pub fn iplEmbreeDeviceRetain(device: IPLEmbreeDevice) -> IPLEmbreeDevice;
}
extern "C" {
    #[doc = " Releases a reference to an Embree device."]
    #[doc = ""]
    #[doc = "\\param  device  The Embree device to release a reference to."]
    pub fn iplEmbreeDeviceRelease(device: *mut IPLEmbreeDevice);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IPLOpenCLDeviceList_t {
    _unused: [u8; 0],
}
pub type IPLOpenCLDeviceList = *mut _IPLOpenCLDeviceList_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IPLOpenCLDevice_t {
    _unused: [u8; 0],
}
pub type IPLOpenCLDevice = *mut _IPLOpenCLDevice_t;
#[repr(i32)]
#[doc = " The type of devices to include when listing OpenCL devices."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IPLOpenCLDeviceType {
    #[doc = " List both CPU and GPU devices."]
    IPL_OPENCLDEVICETYPE_ANY = 0,
    #[doc = " Only list CPU devices."]
    IPL_OPENCLDEVICETYPE_CPU = 1,
    #[doc = " Only list GPU devices."]
    IPL_OPENCLDEVICETYPE_GPU = 2,
}
#[doc = " Specifies requirements that an OpenCL device must meet in order to be considered when listing"]
#[doc = "OpenCL devices."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLOpenCLDeviceSettings {
    #[doc = " The type of device. Set to \\c IPL_OPENCLDEVICETYPE_ANY to consider all available devices."]
    pub type_: IPLOpenCLDeviceType,
    #[doc = " The number of GPU compute units (CUs) that should be reserved for use by Steam Audio. If set to a"]
    #[doc = "non-zero value, then a GPU will be included in the device list only if it can reserve at least"]
    #[doc = "this many CUs. Set to 0 to indicate that Steam Audio can use the entire GPU, in which case all"]
    #[doc = "available GPUs will be considered."]
    #[doc = ""]
    #[doc = "Ignored if \\c type is \\c IPL_OPENCLDEVICETYPE_CPU."]
    pub numCUsToReserve: IPLint32,
    #[doc = " The fraction of reserved CUs that should be used for impulse response (IR) update. IR update"]
    #[doc = "includes: a) ray tracing using Radeon Rays to simulate sound propagation, and/or b) pre-transformation"]
    #[doc = "of IRs for convolution using TrueAudio Next. Steam Audio will only list GPU devices that are able"]
    #[doc = "to subdivide the reserved CUs as per this value. The value must be between 0 and 1."]
    #[doc = ""]
    #[doc = "For example, if \\c numCUsToReserve is \\c 8, and \\c fractionCUsForIRUpdate is \\c 0.5f, then 4 CUs"]
    #[doc = "will be used for IR update and 4 CUs will be used for convolution. Below are typical scenarios:"]
    #[doc = ""]
    #[doc = "-   Using only TrueAudio Next. Set \\c fractionCUsForIRUpdate to \\c 0.5f. This ensures that reserved"]
    #[doc = "CUs are available for IR update as well as convolution."]
    #[doc = ""]
    #[doc = "-   Using TrueAudio Next and Radeon Rays for real-time simulation and rendering. Choosing"]
    #[doc = "\\c fractionCUsForIRUpdate may require some experimentation to utilize reserved CUs optimally. You"]
    #[doc = "can start by setting \\c fractionCUsForIRUpdate to \\c 0.5f. However, if IR calculation has high"]
    #[doc = "latency with these settings, increase \\c fractionCUsForIRUpdate to use more CUs for ray tracing."]
    #[doc = ""]
    #[doc = "-   Using only Radeon Rays. Set \\c fractionCUsForIRUpdate to \\c 1, to make sure all the reserved CUs"]
    #[doc = "are used for ray tracing. If using Steam Audio for preprocessing (e.g. baking reverb), then"]
    #[doc = "consider setting \\c numCUsToReserve to \\c 0 to use the entire GPU for accelerated ray tracing."]
    #[doc = ""]
    #[doc = "Ignored if \\c type is \\c IPL_OPENCLDEVICETYPE_CPU or \\c numCUsToReserve is \\c 0."]
    pub fractionCUsForIRUpdate: IPLfloat32,
    #[doc = " If \\c IPL_TRUE, then the GPU device must support TrueAudio Next. It is not necessary to set this"]
    #[doc = "to \\c IPL_TRUE if \\c numCUsToReserve or \\c fractionCUsForIRUpdate are set to non-zero values."]
    pub requiresTAN: IPLbool,
}
#[doc = " Describes the properties of an OpenCL device. This information can be used to select the most suitable"]
#[doc = "device for your application."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLOpenCLDeviceDesc {
    #[doc = " The OpenCL platform id. Can be cast to \\c cl_platform_id."]
    pub platform: *mut ::std::os::raw::c_void,
    #[doc = " The OpenCL platform name."]
    pub platformName: IPLstring,
    #[doc = " The OpenCL platform vendor's name."]
    pub platformVendor: IPLstring,
    #[doc = " The OpenCL platform version."]
    pub platformVersion: IPLstring,
    #[doc = " The OpenCL device id. Can be cast to \\c cl_device_id."]
    pub device: *mut ::std::os::raw::c_void,
    #[doc = " The OpenCL device name."]
    pub deviceName: IPLstring,
    #[doc = " The OpenCL device vendor's name."]
    pub deviceVendor: IPLstring,
    #[doc = " The OpenCL device version."]
    pub deviceVersion: IPLstring,
    #[doc = " The type of OpenCL device."]
    pub type_: IPLOpenCLDeviceType,
    #[doc = " The number of CUs reserved for convolution. May be \\c 0 if CU reservation is not supported."]
    pub numConvolutionCUs: IPLint32,
    #[doc = " The number of CUs reserved for IR update. May be \\c 0 if CU reservation is not supported."]
    pub numIRUpdateCUs: IPLint32,
    #[doc = " The CU reservation granularity. CUs can only be reserved on this device in multiples of this number."]
    pub granularity: IPLint32,
    #[doc = " A relative performance score of a single CU of this device. Only applicable to supported AMD GPUs."]
    pub perfScore: IPLfloat32,
}
extern "C" {
    #[doc = " Creates an OpenCL device list. This involves listing all available OpenCL devices on the user's system."]
    #[doc = ""]
    #[doc = "\\param  context     The context used to initialize Steam Audio."]
    #[doc = "\\param  settings    The requirements that all listed OpenCL devices must satisfy."]
    #[doc = "\\param  deviceList  [out] The created OpenCL device list."]
    #[doc = ""]
    #[doc = "\\return Status code indicating whether or not the operation succeeded."]
    pub fn iplOpenCLDeviceListCreate(
        context: IPLContext,
        settings: *mut IPLOpenCLDeviceSettings,
        deviceList: *mut IPLOpenCLDeviceList,
    ) -> IPLerror;
}
extern "C" {
    #[doc = " Retains an additional reference to an OpenCL device list."]
    #[doc = ""]
    #[doc = "\\param  deviceList  The OpenCL device list to retain a reference to."]
    #[doc = ""]
    #[doc = "\\return The additional reference to the OpenCL device list."]
    pub fn iplOpenCLDeviceListRetain(deviceList: IPLOpenCLDeviceList) -> IPLOpenCLDeviceList;
}
extern "C" {
    #[doc = " Releases a reference to an OpenCL device list."]
    #[doc = ""]
    #[doc = "\\param  deviceList  The OpenCL device list to release a reference to."]
    pub fn iplOpenCLDeviceListRelease(deviceList: *mut IPLOpenCLDeviceList);
}
extern "C" {
    #[doc = " \\return The number of devices in an OpenCL device list."]
    #[doc = ""]
    #[doc = "\\param  deviceList  The OpenCL device list."]
    pub fn iplOpenCLDeviceListGetNumDevices(deviceList: IPLOpenCLDeviceList) -> IPLint32;
}
extern "C" {
    #[doc = " Retrieves information about a specific device in an OpenCL device list."]
    #[doc = ""]
    #[doc = "\\param  deviceList  The OpenCL device list."]
    #[doc = "\\param  index       The index of the device within the list."]
    #[doc = "\\param  deviceDesc  [out] A descriptor for the properties of the specified OpenCL device."]
    pub fn iplOpenCLDeviceListGetDeviceDesc(
        deviceList: IPLOpenCLDeviceList,
        index: IPLint32,
        deviceDesc: *mut IPLOpenCLDeviceDesc,
    );
}
extern "C" {
    #[doc = " Creates an OpenCL device. The device is specified as an index into an OpenCL device list."]
    #[doc = ""]
    #[doc = "\\param  context     The context used to initialize Steam Audio."]
    #[doc = "\\param  deviceList  The OpenCL device list."]
    #[doc = "\\param  index       The index of the device within the list."]
    #[doc = "\\param  device      [out] The created OpenCL device."]
    #[doc = ""]
    #[doc = "\\return Status code indicating whether or not the operation succeeded."]
    pub fn iplOpenCLDeviceCreate(
        context: IPLContext,
        deviceList: IPLOpenCLDeviceList,
        index: IPLint32,
        device: *mut IPLOpenCLDevice,
    ) -> IPLerror;
}
extern "C" {
    #[doc = " Creates an OpenCL device from an existing OpenCL device created by your application. Steam Audio will"]
    #[doc = "use up to two command queues that you provide for enqueuing OpenCL computations."]
    #[doc = ""]
    #[doc = "\\param  context             The context used to initialize Steam Audio."]
    #[doc = "\\param  convolutionQueue    The \\c cl_command_queue to use for enqueueing convolution work."]
    #[doc = "\\param  irUpdateQueue       The \\c cl_command_queue to use for enqueueing IR update work."]
    #[doc = "\\param  device              [out] The created OpenCL device."]
    #[doc = ""]
    #[doc = "\\return Status code indicating whether or not the operation succeeded."]
    pub fn iplOpenCLDeviceCreateFromExisting(
        context: IPLContext,
        convolutionQueue: *mut ::std::os::raw::c_void,
        irUpdateQueue: *mut ::std::os::raw::c_void,
        device: *mut IPLOpenCLDevice,
    ) -> IPLerror;
}
extern "C" {
    #[doc = " Retains an additional reference to an OpenCL device."]
    #[doc = ""]
    #[doc = "\\param  device  The OpenCL device to retain a reference to."]
    #[doc = ""]
    #[doc = "\\return The additional reference to the OpenCL device."]
    pub fn iplOpenCLDeviceRetain(device: IPLOpenCLDevice) -> IPLOpenCLDevice;
}
extern "C" {
    #[doc = " Releases a reference to an OpenCL device."]
    #[doc = ""]
    #[doc = "\\param  device  The OpenCL device to release a reference to."]
    pub fn iplOpenCLDeviceRelease(device: *mut IPLOpenCLDevice);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IPLRadeonRaysDevice_t {
    _unused: [u8; 0],
}
pub type IPLRadeonRaysDevice = *mut _IPLRadeonRaysDevice_t;
#[doc = " Settings used to create a Radeon Rays device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLRadeonRaysDeviceSettings {
    pub _address: u8,
}
extern "C" {
    #[doc = " Creates a Radeon Rays device."]
    #[doc = ""]
    #[doc = "\\param  openCLDevice    The OpenCL device to use for running Radeon Rays."]
    #[doc = "\\param  settings        The settings to use when creating the Radeon Rays device."]
    #[doc = "\\param  rrDevice        [out] The created Radeon Rays device."]
    #[doc = ""]
    #[doc = "\\return Status code indicating whether or not the operation succeeded."]
    pub fn iplRadeonRaysDeviceCreate(
        openCLDevice: IPLOpenCLDevice,
        settings: *mut IPLRadeonRaysDeviceSettings,
        rrDevice: *mut IPLRadeonRaysDevice,
    ) -> IPLerror;
}
extern "C" {
    #[doc = " Retains an additional reference to a Radeon Rays device."]
    #[doc = ""]
    #[doc = "\\param  device  The Radeon Rays device to retain a reference to."]
    #[doc = ""]
    #[doc = "\\return The additional reference to the Radeon Rays device."]
    pub fn iplRadeonRaysDeviceRetain(device: IPLRadeonRaysDevice) -> IPLRadeonRaysDevice;
}
extern "C" {
    #[doc = " Releases a reference to a Radeon Rays device."]
    #[doc = ""]
    #[doc = "\\param  device  The Radeon Rays device to release a reference to."]
    pub fn iplRadeonRaysDeviceRelease(device: *mut IPLRadeonRaysDevice);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IPLTrueAudioNextDevice_t {
    _unused: [u8; 0],
}
pub type IPLTrueAudioNextDevice = *mut _IPLTrueAudioNextDevice_t;
#[doc = " Settings used to create a TrueAudio Next device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLTrueAudioNextDeviceSettings {
    #[doc = " The number of samples in an audio frame."]
    pub frameSize: IPLint32,
    #[doc = " The number of samples in the impulse responses that will be used for convolution."]
    pub irSize: IPLint32,
    #[doc = " The Ambisonic order of the impulse responses that will be used for convolution."]
    pub order: IPLint32,
    #[doc = " The maximum number of sources that will use TrueAudio Next for convolution."]
    pub maxSources: IPLint32,
}
extern "C" {
    #[doc = " Creates a TrueAudio Next device."]
    #[doc = ""]
    #[doc = "\\param  openCLDevice    The OpenCL device to use for running TrueAudio Next."]
    #[doc = "\\param  settings        The settings to use when creating the TrueAudio Next device."]
    #[doc = "\\param  tanDevice       [out] The created TrueAudio Next device."]
    #[doc = ""]
    #[doc = "\\return Status code indicating whether or not the operation succeeded."]
    pub fn iplTrueAudioNextDeviceCreate(
        openCLDevice: IPLOpenCLDevice,
        settings: *mut IPLTrueAudioNextDeviceSettings,
        tanDevice: *mut IPLTrueAudioNextDevice,
    ) -> IPLerror;
}
extern "C" {
    #[doc = " Retains an additional reference to a TrueAudio Next device."]
    #[doc = ""]
    #[doc = "\\param  device  The TrueAudio Next device to retain a reference to."]
    #[doc = ""]
    #[doc = "\\return The additional reference to the TrueAudio Next device."]
    pub fn iplTrueAudioNextDeviceRetain(device: IPLTrueAudioNextDevice) -> IPLTrueAudioNextDevice;
}
extern "C" {
    #[doc = " Releases a reference to a TrueAudio Next device."]
    #[doc = ""]
    #[doc = "\\param  device  The TrueAudio Next device to release a reference to."]
    pub fn iplTrueAudioNextDeviceRelease(device: *mut IPLTrueAudioNextDevice);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IPLScene_t {
    _unused: [u8; 0],
}
pub type IPLScene = *mut _IPLScene_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IPLStaticMesh_t {
    _unused: [u8; 0],
}
pub type IPLStaticMesh = *mut _IPLStaticMesh_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IPLInstancedMesh_t {
    _unused: [u8; 0],
}
pub type IPLInstancedMesh = *mut _IPLInstancedMesh_t;
#[repr(i32)]
#[doc = " The types of scenes that can be created. Each scene type corresponds to a different ray tracing"]
#[doc = "implementation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IPLSceneType {
    #[doc = " Steam Audio's built-in ray tracer. Supports multi-threading. Runs on all platforms that Steam Audio"]
    #[doc = "supports."]
    IPL_SCENETYPE_DEFAULT = 0,
    #[doc = " The Intel Embree ray tracer. Supports multi-threading. This is a highly optimized implementation, and"]
    #[doc = "is likely to be faster than the Phonon ray tracer. However, Embree requires Windows, Linux, or macOS,"]
    #[doc = "and a 32-bit x86 or 64-bit x86_64 CPU."]
    IPL_SCENETYPE_EMBREE = 1,
    #[doc = " The AMD Radeon Rays ray tracer. This is an OpenCL implementation, and can use either the CPU or any"]
    #[doc = "GPU that supports OpenCL 1.2 or later. If using the GPU, it is likely to be significantly faster than"]
    #[doc = "the Phonon ray tracer. However, with heavy real-time simulation workloads, it may impact your"]
    #[doc = "application's frame rate. On supported AMD GPUs, you can use the Resource Reservation feature to"]
    #[doc = "mitigate this issue."]
    IPL_SCENETYPE_RADEONRAYS = 2,
    #[doc = " Allows you to specify callbacks to your own ray tracer. Useful if your application already uses a"]
    #[doc = "high-performance ray tracer. This option uses the least amount of memory at run-time, since it does"]
    #[doc = "not have to build any ray tracing data structures of its own."]
    IPL_SCENETYPE_CUSTOM = 3,
}
#[doc = " A triangle in 3D space."]
#[doc = ""]
#[doc = "Triangles are specified by their three vertices, which are in turn specified using indices into a"]
#[doc = "vertex array."]
#[doc = ""]
#[doc = "Steam Audio uses a counter-clockwise winding order. This means that when looking at the triangle such that the"]
#[doc = "normal is pointing towards you, the vertices are specified in counter-clockwise order."]
#[doc = ""]
#[doc = "Each triangle must be specified using three vertices; triangle strip or fan representations are"]
#[doc = "not supported."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLTriangle {
    #[doc = " Indices of the three vertices of this triangle."]
    pub indices: [IPLint32; 3usize],
}
#[doc = " The acoustic properties of a surface."]
#[doc = ""]
#[doc = "You can specify the acoustic material properties of each triangle, although typically many triangles will"]
#[doc = "share a common material."]
#[doc = ""]
#[doc = "The acoustic material properties are specified for three frequency bands with center frequencies of"]
#[doc = "400 Hz, 2.5 KHz, and 15 KHz."]
#[doc = ""]
#[doc = "Below are the acoustic material properties for a few standard materials."]
#[doc = ""]
#[doc = "```cpp"]
#[doc = "{\"generic\",{0.10f,0.20f,0.30f,0.05f,0.100f,0.050f,0.030f}}"]
#[doc = "{\"brick\",{0.03f,0.04f,0.07f,0.05f,0.015f,0.015f,0.015f}}"]
#[doc = "{\"concrete\",{0.05f,0.07f,0.08f,0.05f,0.015f,0.002f,0.001f}}"]
#[doc = "{\"ceramic\",{0.01f,0.02f,0.02f,0.05f,0.060f,0.044f,0.011f}}"]
#[doc = "{\"gravel\",{0.60f,0.70f,0.80f,0.05f,0.031f,0.012f,0.008f}},"]
#[doc = "{\"carpet\",{0.24f,0.69f,0.73f,0.05f,0.020f,0.005f,0.003f}}"]
#[doc = "{\"glass\",{0.06f,0.03f,0.02f,0.05f,0.060f,0.044f,0.011f}}"]
#[doc = "{\"plaster\",{0.12f,0.06f,0.04f,0.05f,0.056f,0.056f,0.004f}}"]
#[doc = "{\"wood\",{0.11f,0.07f,0.06f,0.05f,0.070f,0.014f,0.005f}}"]
#[doc = "{\"metal\",{0.20f,0.07f,0.06f,0.05f,0.200f,0.025f,0.010f}}"]
#[doc = "{\"rock\",{0.13f,0.20f,0.24f,0.05f,0.015f,0.002f,0.001f}}"]
#[doc = "```"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLMaterial {
    #[doc = " Fraction of sound energy absorbed at low, middle, high frequencies. Between 0.0 and 1.0."]
    pub absorption: [IPLfloat32; 3usize],
    #[doc = " Fraction of sound energy scattered in a random direction on reflection. Between 0.0 (pure specular) and 1.0"]
    #[doc = "(pure diffuse)."]
    pub scattering: IPLfloat32,
    #[doc = " Fraction of sound energy transmitted through at low, middle, high frequencies. Between 0.0 and 1.0."]
    #[doc = "Only used for direct occlusion calculations."]
    pub transmission: [IPLfloat32; 3usize],
}
#[doc = " A ray in 3D space."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLRay {
    #[doc = " Origin of the ray."]
    pub origin: IPLVector3,
    #[doc = " Unit vector direction of the ray."]
    pub direction: IPLVector3,
}
#[doc = " Information about a ray's intersection with 3D geometry."]
#[doc = ""]
#[doc = "This information should be provided by ray tracer callbacks when using \\c IPL_SCENETYPE_CUSTOM. Not all"]
#[doc = "fields are required."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLHit {
    #[doc = " Distance along the ray from origin to hit point. Set to \\c INFINITY if nothing was hit."]
    pub distance: IPLfloat32,
    #[doc = " (Optional) Index of the primitive hit by the ray. \\c -1 if not provided."]
    pub triangleIndex: IPLint32,
    #[doc = " (Optional) Index of the scene object hit by the ray. \\c -1 if not provided."]
    pub objectIndex: IPLint32,
    #[doc = " (Optional) Index of the material associated with the primitive hit by the ray. \\c -1 if not provided."]
    pub materialIndex: IPLint32,
    #[doc = " Unit length surface normal at the hit point. Ignored if nothing was hit."]
    pub normal: IPLVector3,
    #[doc = " Pointer to the material at the hit point. Ignored if nothing was hit."]
    pub material: *mut IPLMaterial,
}
#[doc = " Callback for calculating the closest hit along a ray."]
#[doc = ""]
#[doc = "Strictly speaking, the intersection is calculated with a ray _interval_ (equivalent to a line segment). Any ray"]
#[doc = "interval may have multiple points of intersection with scene geometry; this function must return information"]
#[doc = "about the point of intersection that is closest to the ray's origin."]
#[doc = ""]
#[doc = "\\param  ray                 The ray to trace."]
#[doc = "\\param  minDistance         The minimum distance from the origin at which an intersection may occur for it"]
#[doc = "to be considered. This function must not return any intersections closer to the"]
#[doc = "origin than this value."]
#[doc = "\\param  maxDistance         The maximum distance from the origin at which an intersection may occur for it"]
#[doc = "to be considered. This function must not return any intersections farther from"]
#[doc = "the origin than this value."]
#[doc = "\\param  hit                 [out] Information describing the ray's intersection with geometry, if any."]
#[doc = "\\param  userData            Pointer to a block of memory containing arbitrary data, specified during the call to"]
#[doc = "\\c iplSceneCreate."]
pub type IPLClosestHitCallback = ::std::option::Option<
    unsafe extern "C" fn(
        ray: *const IPLRay,
        minDistance: IPLfloat32,
        maxDistance: IPLfloat32,
        hit: *mut IPLHit,
        userData: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Callback for calculating whether a ray hits any geometry."]
#[doc = ""]
#[doc = "Strictly speaking, the intersection is calculated with a ray _interval_ (equivalent to a line segment)."]
#[doc = ""]
#[doc = "\\param  ray                 The ray to trace."]
#[doc = "\\param  minDistance         The minimum distance from the origin at which an intersection may occur for it"]
#[doc = "to be considered. This function must not return any intersections closer to the"]
#[doc = "origin than this value."]
#[doc = "\\param  maxDistance         The maximum distance from the origin at which an intersection may occur for it"]
#[doc = "to be considered. This function must not return any intersections farther from"]
#[doc = "the origin than this value."]
#[doc = "\\param  occluded            [out] An integer indicating whether the ray intersects any geometry. A value of 0"]
#[doc = "indicates no intersection, 1 indicates that an intersection exists."]
#[doc = "\\param  userData            Pointer to a block of memory containing arbitrary data, specified during the call to"]
#[doc = "\\c iplSceneCreate."]
pub type IPLAnyHitCallback = ::std::option::Option<
    unsafe extern "C" fn(
        ray: *const IPLRay,
        minDistance: IPLfloat32,
        maxDistance: IPLfloat32,
        occluded: *mut IPLuint8,
        userData: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Callback for calculating the closest hit along a batch of rays."]
#[doc = ""]
#[doc = "Strictly speaking, the intersection is calculated with a ray _interval_ (equivalent to a line segment). Any ray"]
#[doc = "interval may have multiple points of intersection with scene geometry; this function must return information"]
#[doc = "about the point of intersection that is closest to the ray's origin."]
#[doc = ""]
#[doc = "\\param  numRays             The number of rays to trace."]
#[doc = "\\param  rays                Array containing the rays."]
#[doc = "\\param  minDistances        Array containing, for each ray, the minimum distance from the origin at which"]
#[doc = "an intersection may occur for it to be considered."]
#[doc = "\\param  maxDistances        Array containing, for each ray, the maximum distance from the origin at which"]
#[doc = "an intersection may occur for it to be considered."]
#[doc = "\\param  hits                [out] Information describing each ray's intersection with geometry, if any."]
#[doc = "\\param  userData            Pointer to a block of memory containing arbitrary data, specified during the call to"]
#[doc = "\\c iplSceneCreate."]
pub type IPLBatchedClosestHitCallback = ::std::option::Option<
    unsafe extern "C" fn(
        numRays: IPLint32,
        rays: *const IPLRay,
        minDistances: *const IPLfloat32,
        maxDistances: *const IPLfloat32,
        hits: *mut IPLHit,
        userData: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Callback for calculating for each ray in a batch of rays, whether the ray hits any geometry."]
#[doc = ""]
#[doc = "Strictly speaking, the intersection is calculated with a ray _interval_ (equivalent to a line segment)."]
#[doc = ""]
#[doc = "\\param  numRays             The number of rays to trace."]
#[doc = "\\param  rays                Array containing the rays."]
#[doc = "\\param  minDistances        Array containing, for each ray, the minimum distance from the origin at which"]
#[doc = "an intersection may occur for it to be considered."]
#[doc = "\\param  maxDistances        Array containing, for each ray, the maximum distance from the origin at which"]
#[doc = "an intersection may occur for it to be considered."]
#[doc = "\\param  occluded            [out] Array of integers indicating, for each ray, whether the ray intersects any"]
#[doc = "geometry. 0 indicates no intersection, 1 indicates that an intersection exists."]
#[doc = "\\param  userData            Pointer to a block of memory containing arbitrary data, specified during the call to"]
#[doc = "\\c iplSceneCreate."]
pub type IPLBatchedAnyHitCallback = ::std::option::Option<
    unsafe extern "C" fn(
        numRays: IPLint32,
        rays: *const IPLRay,
        minDistances: *const IPLfloat32,
        maxDistances: *const IPLfloat32,
        occluded: *mut IPLuint8,
        userData: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Settings used to create a scene."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLSceneSettings {
    #[doc = " Type of scene to create."]
    pub type_: IPLSceneType,
    #[doc = " Callback for finding the closest hit along a ray. Only for \\c IPL_SCENETYPE_CUSTOM."]
    pub closestHitCallback: IPLClosestHitCallback,
    #[doc = " Callback for finding whether a ray hits anything. Only for \\c IPL_SCENETYPE_CUSTOM."]
    pub anyHitCallback: IPLAnyHitCallback,
    #[doc = " Callback for finding the closest hit along a batch of rays. Only for \\c IPL_SCENETYPE_CUSTOM."]
    pub batchedClosestHitCallback: IPLBatchedClosestHitCallback,
    #[doc = " Callback for finding whether a batch of rays hits anything. Only for \\c IPL_SCENETYPE_CUSTOM."]
    pub batchedAnyHitCallback: IPLBatchedAnyHitCallback,
    #[doc = " Arbitrary user-provided data for use by ray tracing callbacks. Only for \\c IPL_SCENETYPE_CUSTOM."]
    pub userData: *mut ::std::os::raw::c_void,
    #[doc = " Handle to an Embree device. Only for \\c IPL_SCENETYPE_EMBREE."]
    pub embreeDevice: IPLEmbreeDevice,
    #[doc = " Handle to a Radeon Rays device. Only for \\c IPL_SCENETYPE_RADEONRAYS."]
    pub radeonRaysDevice: IPLRadeonRaysDevice,
}
#[doc = " Settings used to create a static mesh."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLStaticMeshSettings {
    #[doc = " Number of vertices."]
    pub numVertices: IPLint32,
    #[doc = " Number of triangles."]
    pub numTriangles: IPLint32,
    #[doc = " Number of materials."]
    pub numMaterials: IPLint32,
    #[doc = " Array containing vertices."]
    pub vertices: *mut IPLVector3,
    #[doc = " Array containing (indexed) triangles."]
    pub triangles: *mut IPLTriangle,
    #[doc = " Array containing, for each triangle, the index of the associated material."]
    pub materialIndices: *mut IPLint32,
    #[doc = " Array of materials."]
    pub materials: *mut IPLMaterial,
}
#[doc = " Settings used to create an instanced mesh."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLInstancedMeshSettings {
    #[doc = " Handle to the scene to be instantiated."]
    pub subScene: IPLScene,
    #[doc = " Local-to-world transform that places the instance within the parent scene."]
    pub transform: IPLMatrix4x4,
}
extern "C" {
    #[doc = " Creates a scene."]
    #[doc = ""]
    #[doc = "A scene does not store any geometry information on its own; for that you need to create one or more"]
    #[doc = "static meshes or instanced meshes and add them to the scene."]
    #[doc = ""]
    #[doc = "\\param  context     The context used to initialize Steam Audio."]
    #[doc = "\\param  settings    The settings to use when creating the scene."]
    #[doc = "\\param  scene       [out] The created scene."]
    #[doc = ""]
    #[doc = "\\return Status code indicating success or failure."]
    pub fn iplSceneCreate(
        context: IPLContext,
        settings: *mut IPLSceneSettings,
        scene: *mut IPLScene,
    ) -> IPLerror;
}
extern "C" {
    #[doc = " Retains an additional reference to a scene."]
    #[doc = ""]
    #[doc = "\\param  scene   The scene to retain a reference to."]
    #[doc = ""]
    #[doc = "\\return The additional reference to the scene."]
    pub fn iplSceneRetain(scene: IPLScene) -> IPLScene;
}
extern "C" {
    #[doc = " Releases a reference to a scene."]
    #[doc = ""]
    #[doc = "\\param  scene   The scene to release a reference to."]
    pub fn iplSceneRelease(scene: *mut IPLScene);
}
extern "C" {
    #[doc = " Loads a scene from a serialized object. Typically, the serialized object will be created from a byte array"]
    #[doc = "loaded from disk or over the network."]
    #[doc = ""]
    #[doc = "\\param  context                     The context used to initialize Steam Audio."]
    #[doc = "\\param  settings                    The settings to use when creating the scene."]
    #[doc = "\\param  serializedObject            The serialized object from which to load the scene."]
    #[doc = "\\param  progressCallback            Callback that reports the percentage of this function's work that has been completed. May be \\c NULL."]
    #[doc = "\\param  progressCallbackUserData    Pointer to arbitrary data that will be passed to the progress callback. May be \\c NULL."]
    #[doc = "\\param  scene                       [out] The created scene."]
    #[doc = ""]
    #[doc = "\\return Status code indicating whether or not the operation succeeded."]
    pub fn iplSceneLoad(
        context: IPLContext,
        settings: *mut IPLSceneSettings,
        serializedObject: IPLSerializedObject,
        progressCallback: IPLProgressCallback,
        progressCallbackUserData: *mut ::std::os::raw::c_void,
        scene: *mut IPLScene,
    ) -> IPLerror;
}
extern "C" {
    #[doc = " Saves a scene to a serialized object. Typically, the serialized object will then be saved to disk."]
    #[doc = ""]
    #[doc = "This function can only be called on a scene created with \\c IPL_SCENETYPE_DEFAULT.**"]
    #[doc = ""]
    #[doc = "\\param  scene               The scene to save."]
    #[doc = "\\param  serializedObject    The serialized object into which to save the scene."]
    pub fn iplSceneSave(scene: IPLScene, serializedObject: IPLSerializedObject);
}
extern "C" {
    #[doc = " Saves a scene to an OBJ file."]
    #[doc = ""]
    #[doc = "An OBJ file is a widely-supported 3D model file format, that can be displayed using a variety of software"]
    #[doc = "on most PC platforms. The OBJ file generated by this function can be useful for detecting problems that"]
    #[doc = "occur when exporting scene data from your application to Steam Audio."]
    #[doc = ""]
    #[doc = "This function can only be called on a scene created with \\c IPL_SCENETYPE_DEFAULT or \\c IPL_SCENETYPE_EMBREE.**"]
    #[doc = ""]
    #[doc = "\\param  scene               The scene to save."]
    #[doc = "\\param  fileBaseName        Absolute or relative path to the OBJ file to generate."]
    pub fn iplSceneSaveOBJ(scene: IPLScene, fileBaseName: IPLstring);
}
extern "C" {
    #[doc = " Commits any changes to the scene."]
    #[doc = ""]
    #[doc = "This function should be called after any calls to the following functions, for the changes to take effect:"]
    #[doc = ""]
    #[doc = "-   \\c iplStaticMeshAdd"]
    #[doc = "-   \\c iplStaticMeshRemove"]
    #[doc = "-   \\c iplInstancedMeshAdd"]
    #[doc = "-   \\c iplInstancedMeshRemove"]
    #[doc = "-   \\c iplInstancedMeshUpdateTransform"]
    #[doc = ""]
    #[doc = "For best performance, call this function once after all changes have been made for a given frame."]
    #[doc = ""]
    #[doc = "This function cannot be called concurrently with any simulation functions.**"]
    #[doc = ""]
    #[doc = "\\param  scene   The scene to commit changes to."]
    pub fn iplSceneCommit(scene: IPLScene);
}
extern "C" {
    #[doc = " Creates a static mesh."]
    #[doc = ""]
    #[doc = "A static mesh represents a triangle mesh that does not change after it is created. A static mesh also contains"]
    #[doc = "an array of acoustic material properties, and a mapping between each of its triangles and their acoustic material"]
    #[doc = "properties."]
    #[doc = ""]
    #[doc = "Static mesh objects should be used for scene geometry that is guaranteed to never change, such as rooms,"]
    #[doc = "buildings, or triangulated terrain. A scene may contain multiple static meshes, although typically one"]
    #[doc = "is sufficient."]
    #[doc = ""]
    #[doc = "\\param  scene       The scene in which the static mesh should be created."]
    #[doc = "\\param  settings    The settings to use when creating the static mesh."]
    #[doc = "\\param  staticMesh  [out] The created static mesh."]
    #[doc = ""]
    #[doc = "\\return Status code indicating whether or not the operation succeeded."]
    pub fn iplStaticMeshCreate(
        scene: IPLScene,
        settings: *mut IPLStaticMeshSettings,
        staticMesh: *mut IPLStaticMesh,
    ) -> IPLerror;
}
extern "C" {
    #[doc = " Retains an additional reference to a static mesh."]
    #[doc = ""]
    #[doc = "\\param  staticMesh  The static mesh to retain a reference to."]
    #[doc = ""]
    #[doc = "\\return The additional reference to the static mesh."]
    pub fn iplStaticMeshRetain(staticMesh: IPLStaticMesh) -> IPLStaticMesh;
}
extern "C" {
    #[doc = " Releases a reference to a static mesh."]
    #[doc = ""]
    #[doc = "\\param  staticMesh  The static mesh to release a reference to."]
    pub fn iplStaticMeshRelease(staticMesh: *mut IPLStaticMesh);
}
extern "C" {
    #[doc = " Loads a static mesh from a serialized object. Typically, the serialized object will be created from a byte array"]
    #[doc = "loaded from disk or over the network."]
    #[doc = ""]
    #[doc = "\\param  scene                       The scene in which the static mesh should be created."]
    #[doc = "\\param  serializedObject            The serialized object from which to load the scene."]
    #[doc = "\\param  progressCallback            Callback that reports the percentage of this function's work that has been completed. May be \\c NULL."]
    #[doc = "\\param  progressCallbackUserData    Pointer to arbitrary data that will be passed to the progress callback. May be \\c NULL."]
    #[doc = "\\param  staticMesh                  [out] The created static mesh."]
    #[doc = ""]
    #[doc = "\\return Status code indicating whether or not the operation succeeded."]
    pub fn iplStaticMeshLoad(
        scene: IPLScene,
        serializedObject: IPLSerializedObject,
        progressCallback: IPLProgressCallback,
        progressCallbackUserData: *mut ::std::os::raw::c_void,
        staticMesh: *mut IPLStaticMesh,
    ) -> IPLerror;
}
extern "C" {
    #[doc = " Saves a static mesh to a serialized object. Typically, the serialized object will then be saved to disk."]
    #[doc = ""]
    #[doc = "This function can only be called on a static mesh that is part of a scene created with \\c IPL_SCENETYPE_DEFAULT."]
    #[doc = ""]
    #[doc = "\\param  staticMesh          The static mesh to save."]
    #[doc = "\\param  serializedObject    The serialized object into which to save the static mesh."]
    pub fn iplStaticMeshSave(staticMesh: IPLStaticMesh, serializedObject: IPLSerializedObject);
}
extern "C" {
    #[doc = " Adds a static mesh to a scene."]
    #[doc = ""]
    #[doc = "This function should be called after \\c iplStaticMeshCreate, or at any point after \\c iplStaticMeshRemove,"]
    #[doc = "for the static mesh to start affecting sound propagation."]
    #[doc = ""]
    #[doc = "After calling this function, \\c iplSceneCommit must be called for the changes to take effect."]
    #[doc = ""]
    #[doc = "\\param  staticMesh  The static mesh to add."]
    #[doc = "\\param  scene       The scene to which to add the static mesh. This must be the scene which was passed when"]
    #[doc = "calling \\c iplStaticMeshCreate."]
    pub fn iplStaticMeshAdd(staticMesh: IPLStaticMesh, scene: IPLScene);
}
extern "C" {
    #[doc = " Removes a static mesh from a scene."]
    #[doc = ""]
    #[doc = "After this function is called, the static mesh will stop affecting sound propagation, until it is"]
    #[doc = "added back using \\c iplStaticMeshAdd."]
    #[doc = ""]
    #[doc = "After calling this function, \\c iplSceneCommit must be called for the changes to take effect."]
    #[doc = ""]
    #[doc = "\\param  staticMesh  The static mesh to remove."]
    #[doc = "\\param  scene       The scene from which to remove the static mesh. This must be the scene which was passed when"]
    #[doc = "calling \\c iplStaticMeshCreate."]
    pub fn iplStaticMeshRemove(staticMesh: IPLStaticMesh, scene: IPLScene);
}
extern "C" {
    #[doc = " Creates an instanced mesh."]
    #[doc = ""]
    #[doc = "An instanced mesh takes one scene and positions it within another scene. This is useful if you have the"]
    #[doc = "same object, like a pillar, that you want to instantiate multiple times within the same scene. A scene"]
    #[doc = "can be instantiated multiple times within another scene, without incurring any significant memory overhead."]
    #[doc = ""]
    #[doc = "The instanced mesh can be moved, rotated, and scaled freely at any time, providing an easy way to implement"]
    #[doc = "dynamic objects whose motion can be described purely in terms of rigid-body transformations."]
    #[doc = ""]
    #[doc = "\\param  scene           The scene in which the instanced mesh should be created."]
    #[doc = "\\param  settings        The settings used to create the instanced mesh."]
    #[doc = "\\param  instancedMesh   [out] The created instanced mesh."]
    #[doc = ""]
    #[doc = "\\return Status code indicating whether or not the operation succeeded."]
    pub fn iplInstancedMeshCreate(
        scene: IPLScene,
        settings: *mut IPLInstancedMeshSettings,
        instancedMesh: *mut IPLInstancedMesh,
    ) -> IPLerror;
}
extern "C" {
    #[doc = " Retains an additional reference to a instanced mesh."]
    #[doc = ""]
    #[doc = "\\param  instancedMesh   The instanced mesh to retain a reference to."]
    #[doc = ""]
    #[doc = "\\return The additional reference to the instanced mesh."]
    pub fn iplInstancedMeshRetain(instancedMesh: IPLInstancedMesh) -> IPLInstancedMesh;
}
extern "C" {
    #[doc = " Releases a reference to a instanced mesh."]
    #[doc = ""]
    #[doc = "\\param  instancedMesh   The instanced mesh to release a reference to."]
    pub fn iplInstancedMeshRelease(instancedMesh: *mut IPLInstancedMesh);
}
extern "C" {
    #[doc = " Adds an instanced mesh to a scene."]
    #[doc = ""]
    #[doc = "This function should be called after \\c iplInstancedMeshCreate, or at any point after \\c iplInstancedMeshRemove,"]
    #[doc = "for the instanced mesh to start affecting sound propagation."]
    #[doc = ""]
    #[doc = "After calling this function, \\c iplSceneCommit must be called for the changes to take effect."]
    #[doc = ""]
    #[doc = "\\param  instancedMesh   The instanced mesh to add."]
    #[doc = "\\param  scene           The scene to which to add the instanced mesh. This must be the scene which was passed when"]
    #[doc = "calling \\c iplInstancedMeshCreate."]
    pub fn iplInstancedMeshAdd(instancedMesh: IPLInstancedMesh, scene: IPLScene);
}
extern "C" {
    #[doc = " Removes an instanced mesh from a scene."]
    #[doc = ""]
    #[doc = "After this function is called, the instanced mesh will stop affecting sound propagation, until it is"]
    #[doc = "added back using \\c iplInstancedMeshAdd."]
    #[doc = ""]
    #[doc = "After calling this function, \\c iplSceneCommit must be called for the changes to take effect."]
    #[doc = ""]
    #[doc = "\\param  instancedMesh   The instanced mesh to remove."]
    #[doc = "\\param  scene           The scene from which to remove the instanced mesh. This must be the scene which was passed when"]
    #[doc = "calling \\c iplInstancedMeshCreate."]
    pub fn iplInstancedMeshRemove(instancedMesh: IPLInstancedMesh, scene: IPLScene);
}
extern "C" {
    #[doc = " Updates the local-to-world transform of an instanced mesh within its parent scene."]
    #[doc = ""]
    #[doc = "This function allows the instanced mesh to be moved, rotated, and scaled dynamically."]
    #[doc = ""]
    #[doc = "After calling this function, \\c iplSceneCommit must be called for the changes to take effect."]
    #[doc = ""]
    #[doc = "\\param  instancedMesh   The instanced mesh whose transform is to be updated."]
    #[doc = "\\param  scene           The parent scene that contains the instanced mesh."]
    #[doc = "\\param  transform       The new 4x4 local-to-world transform matrix."]
    pub fn iplInstancedMeshUpdateTransform(
        instancedMesh: IPLInstancedMesh,
        scene: IPLScene,
        transform: IPLMatrix4x4,
    );
}
#[repr(i32)]
#[doc = " Supported speaker layouts."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IPLSpeakerLayoutType {
    #[doc = " Mono."]
    IPL_SPEAKERLAYOUTTYPE_MONO = 0,
    #[doc = " Stereo (left, right)."]
    IPL_SPEAKERLAYOUTTYPE_STEREO = 1,
    #[doc = " Front left, front right, rear left, rear right."]
    IPL_SPEAKERLAYOUTTYPE_QUADRAPHONIC = 2,
    #[doc = " Front left, front right, front center, LFE, rear left, rear right."]
    IPL_SPEAKERLAYOUTTYPE_SURROUND_5_1 = 3,
    #[doc = " Front left, front right, front center, LFE, rear left, rear right, side left, side right."]
    IPL_SPEAKERLAYOUTTYPE_SURROUND_7_1 = 4,
    #[doc = " User-defined speaker layout. See \\c IPLSpeakerLayout."]
    IPL_SPEAKERLAYOUTTYPE_CUSTOM = 5,
}
#[repr(i32)]
#[doc = " Supported channel ordering and normalization schemes for Ambisonic audio."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IPLAmbisonicsType {
    #[doc = " ACN channel ordering, orthonormal spherical harmonics."]
    IPL_AMBISONICSTYPE_N3D = 0,
    #[doc = " ACN channel ordering, semi-normalized spherical harmonics. AmbiX format."]
    IPL_AMBISONICSTYPE_SN3D = 1,
    #[doc = " Furse-Malham (B-format)."]
    IPL_AMBISONICSTYPE_FUMA = 2,
}
#[repr(i32)]
#[doc = " States that an audio effect can be left in after processing a frame of audio."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IPLAudioEffectState {
    #[doc = " One or more samples of tail remain in the effect's internal buffers."]
    IPL_AUDIOEFFECTSTATE_TAILREMAINING = 0,
    #[doc = " No tail remains in the effect's internal buffers."]
    IPL_AUDIOEFFECTSTATE_TAILCOMPLETE = 1,
}
#[doc = " Describes a standard or custom speaker layout."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLSpeakerLayout {
    #[doc = " See \\c IPLSpeakerLayoutType."]
    pub type_: IPLSpeakerLayoutType,
    #[doc = " Number of speakers. Only for IPL_SPEAKERLAYOUTTYPE_CUSTOM."]
    pub numSpeakers: IPLint32,
    #[doc = " Array of unit-length directions for each speaker. Only for IPL_SPEAKERLAYOUTTYPE_CUSTOM."]
    pub speakers: *mut IPLVector3,
}
#[doc = " Global settings for audio signal processing."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLAudioSettings {
    #[doc = " Sampling rate, in Hz."]
    pub samplingRate: IPLint32,
    #[doc = " Frame size, in samples. Independent of number of channels."]
    pub frameSize: IPLint32,
}
    use std::sync::atomic::AtomicPtr;
#[doc = " Describes an audio buffer. All audio buffers passed to Steam Audio must be deinterleaved."]
#[repr(C)]
#[derive(Debug)]
pub struct IPLAudioBuffer {
    #[doc = " Number of channels."]
    pub numChannels: IPLint32,
    #[doc = " Number of samples per channel."]
    pub numSamples: IPLint32,
    #[doc = " Array of pointers to sample data for each channel. Allocation of sample data is up to the user."]
    pub data: AtomicPtr<AtomicPtr<IPLfloat32>>,
}
extern "C" {
    #[doc = " Allocates an audio buffer."]
    #[doc = ""]
    #[doc = "All audio buffers are uncompressed PCM with 32-bit floating-point samples."]
    #[doc = ""]
    #[doc = "Internally, all audio buffers are stored deinterleaved for performance reasons. If your audio engine provides"]
    #[doc = "interleaved audio buffers, you must use \\c iplAudioBufferInterleave and \\c iplAudioBufferDeinterleave to explicitly"]
    #[doc = "convert to/from deinterleaved format. If your audio engine provides deinterleaved audio buffers, you can"]
    #[doc = "pass them directly using \\c IPLAudioBuffer, thus avoiding the processing and memory overhead of an extra audio buffer."]
    #[doc = ""]
    #[doc = "\\param  context         The context used to initialize Steam Audio."]
    #[doc = "\\param  numChannels     Number of channels."]
    #[doc = "\\param  numSamples      Number of samples per channel."]
    #[doc = "\\param  audioBuffer     The audio buffer to allocate."]
    #[doc = ""]
    #[doc = "\\return Status code indicating whether or not the operation succeeded."]
    pub fn iplAudioBufferAllocate(
        context: IPLContext,
        numChannels: IPLint32,
        numSamples: IPLint32,
        audioBuffer: *mut IPLAudioBuffer,
    ) -> IPLerror;
}
extern "C" {
    #[doc = " Frees an audio buffer."]
    #[doc = ""]
    #[doc = "\\param  context         The context used to initialize Steam Audio."]
    #[doc = "\\param  audioBuffer     The audio buffer to free."]
    pub fn iplAudioBufferFree(context: IPLContext, audioBuffer: *mut IPLAudioBuffer);
}
extern "C" {
    #[doc = " Reads samples from an audio buffer and interleaves them into a user-provided array."]
    #[doc = ""]
    #[doc = "\\param  context         The context used to initialize Steam Audio."]
    #[doc = "\\param  src             The audio buffer to read from."]
    #[doc = "\\param  dst             The interleaved array to write into."]
    pub fn iplAudioBufferInterleave(
        context: IPLContext,
        src: *mut IPLAudioBuffer,
        dst: *mut IPLfloat32,
    );
}
extern "C" {
    #[doc = " Writes interleaved samples from a user-provided array into an audio buffer."]
    #[doc = ""]
    #[doc = "\\param  context         The context used to initialize Steam Audio."]
    #[doc = "\\param  src             The interleaved array to read from."]
    #[doc = "\\param  dst             The audio buffer to write into."]
    pub fn iplAudioBufferDeinterleave(
        context: IPLContext,
        src: *mut IPLfloat32,
        dst: *mut IPLAudioBuffer,
    );
}
extern "C" {
    #[doc = " Mixes one audio buffer into another."]
    #[doc = ""]
    #[doc = "Both audio buffers must have the same number of channels and samples."]
    #[doc = ""]
    #[doc = "\\param  context     The context used to initialize Steam Audio."]
    #[doc = "\\param  in          The source audio buffer."]
    #[doc = "\\param  mix         The destination audio buffer, into which the source should be mixed."]
    pub fn iplAudioBufferMix(
        context: IPLContext,
        in_: *mut IPLAudioBuffer,
        mix: *mut IPLAudioBuffer,
    );
}
extern "C" {
    #[doc = " Downmixes a multi-channel audio buffer into a mono audio buffer."]
    #[doc = ""]
    #[doc = "Both audio buffers must have the same number of samples."]
    #[doc = ""]
    #[doc = "Downmixing is performed by summing up the source channels and dividing the result by the"]
    #[doc = "number of source channels. If this is not the desired downmixing behavior, we recommend"]
    #[doc = "that downmixing be performed manually."]
    #[doc = ""]
    #[doc = "\\param  context The context used to initialize Steam Audio."]
    #[doc = "\\param  in      The source audio buffer."]
    #[doc = "\\param  out     The destination audio buffer."]
    pub fn iplAudioBufferDownmix(
        context: IPLContext,
        in_: *mut IPLAudioBuffer,
        out: *mut IPLAudioBuffer,
    );
}
extern "C" {
    #[doc = " Converts an Ambisonic audio buffer from one Ambisonic format to another."]
    #[doc = ""]
    #[doc = "Both audio buffers must have the same number of samples."]
    #[doc = ""]
    #[doc = "This conversion can be applied in-place, i.e., \\c in and \\c out can be the same"]
    #[doc = "audio buffer."]
    #[doc = ""]
    #[doc = "Steam Audio's \"native\" Ambisonic format is N3D, so for best performance, keep all"]
    #[doc = "Ambisonic data in N3D format except when exchanging data with your audio engine."]
    #[doc = ""]
    #[doc = "\\param  context     The context used to initialize Steam Audio."]
    #[doc = "\\param  inType      Ambisonic format of \\c in."]
    #[doc = "\\param  outType     Ambisonic format that \\c out should be in."]
    #[doc = "\\param  in          The source audio buffer."]
    #[doc = "\\param  out         The destination audio buffer."]
    pub fn iplAudioBufferConvertAmbisonics(
        context: IPLContext,
        inType: IPLAmbisonicsType,
        outType: IPLAmbisonicsType,
        in_: *mut IPLAudioBuffer,
        out: *mut IPLAudioBuffer,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IPLHRTF_t {
    _unused: [u8; 0],
}
pub type IPLHRTF = *mut _IPLHRTF_t;
#[repr(i32)]
#[doc = " The type of HRTF to use."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IPLHRTFType {
    #[doc = " The built-in HRTF."]
    IPL_HRTFTYPE_DEFAULT = 0,
    #[doc = " An HRTF loaded from a SOFA file."]
    IPL_HRTFTYPE_SOFA = 1,
}
#[doc = " Settings used to create an HRTF object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLHRTFSettings {
    #[doc = " The type of HRTF to create."]
    pub type_: IPLHRTFType,
    #[doc = " SOFA file from which to load HRTF data. Only for \\c IPL_HRTFTYPE_SOFA."]
    pub sofaFileName: *const ::std::os::raw::c_char,
}
extern "C" {
    #[doc = " Creates an HRTF."]
    #[doc = ""]
    #[doc = "Calling this function is somewhat expensive; avoid creating HRTF objects in your audio thread at all"]
    #[doc = "if possible."]
    #[doc = ""]
    #[doc = "This function is not thread-safe. Do not simultaneously call it from multiple threads."]
    #[doc = ""]
    #[doc = "\\param  context         The context used to initialize Steam Audio."]
    #[doc = "\\param  audioSettings   Global audio processing settings."]
    #[doc = "\\param  hrtfSettings    The settings used to create the HRTF object."]
    #[doc = "\\param  hrtf            [out] The created HRTF object."]
    #[doc = ""]
    #[doc = "\\return Status code indicating whether or not the operation succeeded."]
    pub fn iplHRTFCreate(
        context: IPLContext,
        audioSettings: *mut IPLAudioSettings,
        hrtfSettings: *mut IPLHRTFSettings,
        hrtf: *mut IPLHRTF,
    ) -> IPLerror;
}
extern "C" {
    #[doc = " Retains an additional reference to an HRTF object."]
    #[doc = ""]
    #[doc = "\\param  hrtf    The HRTF object to retain a reference to."]
    #[doc = ""]
    #[doc = "\\return The additional reference to the HRTF object."]
    pub fn iplHRTFRetain(hrtf: IPLHRTF) -> IPLHRTF;
}
extern "C" {
    #[doc = " Releases a reference to an HRTF object."]
    #[doc = ""]
    #[doc = "\\param  hrtf    The HRTF object to release a reference to."]
    pub fn iplHRTFRelease(hrtf: *mut IPLHRTF);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IPLPanningEffect_t {
    _unused: [u8; 0],
}
pub type IPLPanningEffect = *mut _IPLPanningEffect_t;
#[doc = " Settings used to create a panning effect."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLPanningEffectSettings {
    #[doc = " The speaker layout to pan input audio to."]
    pub speakerLayout: IPLSpeakerLayout,
}
#[doc = " Parameters for applying a panning effect to an audio buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLPanningEffectParams {
    #[doc = " Unit vector pointing from the listener towards the source."]
    pub direction: IPLVector3,
}
extern "C" {
    #[doc = " Creates a panning effect."]
    #[doc = ""]
    #[doc = "\\param  context         The context used to initialize Steam Audio."]
    #[doc = "\\param  audioSettings   Global audio processing settings."]
    #[doc = "\\param  effectSettings  The settings to use when creating the panning effect."]
    #[doc = "\\param  effect          [out] The created panning effect."]
    #[doc = ""]
    #[doc = "\\return Status code indicating whether or not the operation succeeded."]
    pub fn iplPanningEffectCreate(
        context: IPLContext,
        audioSettings: *mut IPLAudioSettings,
        effectSettings: *mut IPLPanningEffectSettings,
        effect: *mut IPLPanningEffect,
    ) -> IPLerror;
}
extern "C" {
    #[doc = " Retains an additional reference to a panning effect."]
    #[doc = ""]
    #[doc = "\\param  effect  The panning effect to retain a reference to."]
    #[doc = ""]
    #[doc = "\\return The additional reference to the panning effect."]
    pub fn iplPanningEffectRetain(effect: IPLPanningEffect) -> IPLPanningEffect;
}
extern "C" {
    #[doc = " Releases a reference to a panning effect."]
    #[doc = ""]
    #[doc = "\\param  effect  The panning effect to release a reference to."]
    pub fn iplPanningEffectRelease(effect: *mut IPLPanningEffect);
}
extern "C" {
    #[doc = " Resets the internal processing state of a panning effect."]
    #[doc = ""]
    #[doc = "\\param  effect  The panning effect to reset."]
    pub fn iplPanningEffectReset(effect: IPLPanningEffect);
}
extern "C" {
    #[doc = " Applies a panning effect to an audio buffer."]
    #[doc = ""]
    #[doc = "This effect CANNOT be applied in-place."]
    #[doc = ""]
    #[doc = "\\param  effect  The panning effect to apply."]
    #[doc = "\\param  params  Parameters for applying the effect."]
    #[doc = "\\param  in      The input audio buffer. Must be 1-channel."]
    #[doc = "\\param  out     The output audio buffer. Must have as many channels as needed for the speaker layout"]
    #[doc = "specified when creating the panning effect. For example, if the speaker layout is"]
    #[doc = "\\c IPL_SPEAKERLAYOUTTYPE_SURROUND_5_1, the output buffer must contain 6 channels."]
    #[doc = ""]
    #[doc = "\\return \\c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE to indicate that this effect does not generate any tail samples."]
    pub fn iplPanningEffectApply(
        effect: IPLPanningEffect,
        params: *mut IPLPanningEffectParams,
        in_: *mut IPLAudioBuffer,
        out: *mut IPLAudioBuffer,
    ) -> IPLAudioEffectState;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IPLBinauralEffect_t {
    _unused: [u8; 0],
}
pub type IPLBinauralEffect = *mut _IPLBinauralEffect_t;
#[repr(i32)]
#[doc = " Techniques for interpolating HRTF data. This is used when rendering a point source whose position relative to"]
#[doc = "the listener is not contained in the measured HRTF data."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IPLHRTFInterpolation {
    #[doc = " Nearest-neighbor filtering, i.e., no interpolation. Selects the measurement location that is closest to"]
    #[doc = "the source's actual location."]
    IPL_HRTFINTERPOLATION_NEAREST = 0,
    #[doc = " Bilinear filtering. Incurs a relatively high CPU overhead as compared to nearest-neighbor filtering, so use"]
    #[doc = "this for sounds where it has a significant benefit. Typically, bilinear filtering is most useful for wide-band"]
    #[doc = "noise-like sounds, such as radio static, mechanical noise, fire, etc."]
    IPL_HRTFINTERPOLATION_BILINEAR = 1,
}
#[doc = " Settings used to create a binaural effect."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLBinauralEffectSettings {
    #[doc = " The HRTF to use."]
    pub hrtf: IPLHRTF,
}
#[doc = " Parameters for applying a binaural effect to an audio buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLBinauralEffectParams {
    #[doc = " Unit vector pointing from the listener towards the source."]
    pub direction: IPLVector3,
    #[doc = " The interpolation technique to use."]
    pub interpolation: IPLHRTFInterpolation,
    #[doc = " Amount to blend input audio with spatialized audio. When set to 0, output audio is not spatialized at all"]
    #[doc = "and is close to input audio. If set to 1, output audio is fully spatialized."]
    pub spatialBlend: IPLfloat32,
    #[doc = " The HRTF to use."]
    pub hrtf: IPLHRTF,
}
extern "C" {
    #[doc = " Creates a binaural effect."]
    #[doc = ""]
    #[doc = "\\param  context         The context used to initialize Steam Audio."]
    #[doc = "\\param  audioSettings   Global audio processing settings."]
    #[doc = "\\param  effectSettings  The settings to use when creating the binaural effect."]
    #[doc = "\\param  effect          [out] The created binaural effect."]
    #[doc = ""]
    #[doc = "\\return Status code indicating whether or not the operation succeeded."]
    pub fn iplBinauralEffectCreate(
        context: IPLContext,
        audioSettings: *mut IPLAudioSettings,
        effectSettings: *mut IPLBinauralEffectSettings,
        effect: *mut IPLBinauralEffect,
    ) -> IPLerror;
}
extern "C" {
    #[doc = " Retains an additional reference to a binaural effect."]
    #[doc = ""]
    #[doc = "\\param  effect  The binaural effect to retain a reference to."]
    #[doc = ""]
    #[doc = "\\return The additional reference to the binaural effect."]
    pub fn iplBinauralEffectRetain(effect: IPLBinauralEffect) -> IPLBinauralEffect;
}
extern "C" {
    #[doc = " Releases a reference to a binaural effect."]
    #[doc = ""]
    #[doc = "\\param  effect  The binaural effect to release a reference to."]
    pub fn iplBinauralEffectRelease(effect: *mut IPLBinauralEffect);
}
extern "C" {
    #[doc = " Resets the internal processing state of a binaural effect."]
    #[doc = ""]
    #[doc = "\\param  effect  The binaural effect to reset."]
    pub fn iplBinauralEffectReset(effect: IPLBinauralEffect);
}
extern "C" {
    #[doc = " Applies a binaural effect to an audio buffer."]
    #[doc = ""]
    #[doc = "This effect CANNOT be applied in-place."]
    #[doc = ""]
    #[doc = "\\param  effect  The binaural effect to apply."]
    #[doc = "\\param  params  Parameters for applying the effect."]
    #[doc = "\\param  in      The input audio buffer. Must be 1- or 2-channel."]
    #[doc = "\\param  out     The output audio buffer. Must be 2-channel."]
    #[doc = ""]
    #[doc = "\\return \\c IPL_AUDIOEFFECTSTATE_TAILREMAINING if any tail samples remain in the effect's internal buffers, or"]
    #[doc = "\\c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE otherwise."]
    pub fn iplBinauralEffectApply(
        effect: IPLBinauralEffect,
        params: *mut IPLBinauralEffectParams,
        in_: *mut IPLAudioBuffer,
        out: *mut IPLAudioBuffer,
    ) -> IPLAudioEffectState;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IPLVirtualSurroundEffect_t {
    _unused: [u8; 0],
}
pub type IPLVirtualSurroundEffect = *mut _IPLVirtualSurroundEffect_t;
#[doc = " Settings used to create a virtual surround effect."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLVirtualSurroundEffectSettings {
    #[doc = " The speaker layout that will be used by input audio buffers."]
    pub speakerLayout: IPLSpeakerLayout,
    #[doc = " The HRTF to use."]
    pub hrtf: IPLHRTF,
}
#[doc = " Parameters for applying a virtual surround effect to an audio buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLVirtualSurroundEffectParams {
    #[doc = " The HRTF to use."]
    pub hrtf: IPLHRTF,
}
extern "C" {
    #[doc = " Creates a virtual surround effect."]
    #[doc = ""]
    #[doc = "\\param  context         The context used to initialize Steam Audio."]
    #[doc = "\\param  audioSettings   Global audio processing settings."]
    #[doc = "\\param  effectSettings  The settings to use when creating the virtual surround effect."]
    #[doc = "\\param  effect          [out] The created virtual surround effect."]
    #[doc = ""]
    #[doc = "\\return Status code indicating whether or not the operation succeeded."]
    pub fn iplVirtualSurroundEffectCreate(
        context: IPLContext,
        audioSettings: *mut IPLAudioSettings,
        effectSettings: *mut IPLVirtualSurroundEffectSettings,
        effect: *mut IPLVirtualSurroundEffect,
    ) -> IPLerror;
}
extern "C" {
    #[doc = " Retains an additional reference to a virtual surround effect."]
    #[doc = ""]
    #[doc = "\\param  effect  The virtual surround effect to retain a reference to."]
    #[doc = ""]
    #[doc = "\\return The additional reference to the virtual surround effect."]
    pub fn iplVirtualSurroundEffectRetain(
        effect: IPLVirtualSurroundEffect,
    ) -> IPLVirtualSurroundEffect;
}
extern "C" {
    #[doc = " Releases a reference to a virtual surround effect."]
    #[doc = ""]
    #[doc = "\\param  effect  The virtual surround effect to release a reference to."]
    pub fn iplVirtualSurroundEffectRelease(effect: *mut IPLVirtualSurroundEffect);
}
extern "C" {
    #[doc = " Resets the internal processing state of a virtual surround effect."]
    #[doc = ""]
    #[doc = "\\param  effect  The virtual surround effect to reset."]
    pub fn iplVirtualSurroundEffectReset(effect: IPLVirtualSurroundEffect);
}
extern "C" {
    #[doc = " Applies a virtual surround effect to an audio buffer."]
    #[doc = ""]
    #[doc = "This effect CANNOT be applied in-place."]
    #[doc = ""]
    #[doc = "\\param  effect  The virtual surround effect to apply."]
    #[doc = "\\param  params  Parameters for applying the effect."]
    #[doc = "\\param  in      The input audio buffer. Must have as many channels as needed for the speaker layout"]
    #[doc = "specified when creating the virtual surround effect."]
    #[doc = "\\param  out     The output audio buffer. Must be 2-channel."]
    #[doc = ""]
    #[doc = "\\return \\c IPL_AUDIOEFFECTSTATE_TAILREMAINING if any tail samples remain in the effect's internal buffers, or"]
    #[doc = "\\c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE otherwise."]
    pub fn iplVirtualSurroundEffectApply(
        effect: IPLVirtualSurroundEffect,
        params: *mut IPLVirtualSurroundEffectParams,
        in_: *mut IPLAudioBuffer,
        out: *mut IPLAudioBuffer,
    ) -> IPLAudioEffectState;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IPLAmbisonicsEncodeEffect_t {
    _unused: [u8; 0],
}
pub type IPLAmbisonicsEncodeEffect = *mut _IPLAmbisonicsEncodeEffect_t;
#[doc = " Settings used to create an Ambisonics encode effect."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLAmbisonicsEncodeEffectSettings {
    #[doc = " Maximum Ambisonics order to encode audio buffers to."]
    pub maxOrder: IPLint32,
}
#[doc = " Parameters for applying an Ambisonics encode effect to an audio buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLAmbisonicsEncodeEffectParams {
    #[doc = " Unit vector pointing from the listener towards the source."]
    pub direction: IPLVector3,
    #[doc = " Ambisonic order of the output buffer. May be less than the \\c maxOrder specified when creating the effect,"]
    #[doc = "in which case the effect will generate fewer output channels, reducing CPU usage."]
    pub order: IPLint32,
}
extern "C" {
    #[doc = " Creates an Ambisonics encode effect."]
    #[doc = ""]
    #[doc = "\\param  context         The context used to initialize Steam Audio."]
    #[doc = "\\param  audioSettings   Global audio processing settings."]
    #[doc = "\\param  effectSettings  The settings to use when creating the Ambisonics encode effect."]
    #[doc = "\\param  effect          [out] The created Ambisonics encode effect."]
    #[doc = ""]
    #[doc = "\\return Status code indicating whether or not the operation succeeded."]
    pub fn iplAmbisonicsEncodeEffectCreate(
        context: IPLContext,
        audioSettings: *mut IPLAudioSettings,
        effectSettings: *mut IPLAmbisonicsEncodeEffectSettings,
        effect: *mut IPLAmbisonicsEncodeEffect,
    ) -> IPLerror;
}
extern "C" {
    #[doc = " Retains an additional reference to an Ambisonics encode effect."]
    #[doc = ""]
    #[doc = "\\param  effect  The Ambisonics encode effect to retain a reference to."]
    #[doc = ""]
    #[doc = "\\return The additional reference to the Ambisonics encode effect."]
    pub fn iplAmbisonicsEncodeEffectRetain(
        effect: IPLAmbisonicsEncodeEffect,
    ) -> IPLAmbisonicsEncodeEffect;
}
extern "C" {
    #[doc = " Releases a reference to an Ambisonics encode effect."]
    #[doc = ""]
    #[doc = "\\param  effect  The Ambisonics encode effect to release a reference to."]
    pub fn iplAmbisonicsEncodeEffectRelease(effect: *mut IPLAmbisonicsEncodeEffect);
}
extern "C" {
    #[doc = " Resets the internal processing state of an Ambisonics encode effect."]
    #[doc = ""]
    #[doc = "\\param  effect  The Ambisonics encode effect to reset."]
    pub fn iplAmbisonicsEncodeEffectReset(effect: IPLAmbisonicsEncodeEffect);
}
extern "C" {
    #[doc = " Applies an Ambisonics encode effect to an audio buffer."]
    #[doc = ""]
    #[doc = "This effect CANNOT be applied in-place."]
    #[doc = ""]
    #[doc = "\\param  effect  The Ambisonics encode effect to apply."]
    #[doc = "\\param  params  Parameters for applying the effect."]
    #[doc = "\\param  in      The input audio buffer. Must be 1-channel."]
    #[doc = "\\param  out     The output audio buffer. Must have as many channels as needed for the"]
    #[doc = "Ambisonics order specified when creating the effect."]
    #[doc = ""]
    #[doc = "\\return \\c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE to indicate that this effect does not generate any tail samples."]
    pub fn iplAmbisonicsEncodeEffectApply(
        effect: IPLAmbisonicsEncodeEffect,
        params: *mut IPLAmbisonicsEncodeEffectParams,
        in_: *mut IPLAudioBuffer,
        out: *mut IPLAudioBuffer,
    ) -> IPLAudioEffectState;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IPLAmbisonicsPanningEffect_t {
    _unused: [u8; 0],
}
pub type IPLAmbisonicsPanningEffect = *mut _IPLAmbisonicsPanningEffect_t;
#[doc = " Settings used to create an Ambisonics panning effect."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLAmbisonicsPanningEffectSettings {
    #[doc = " The speaker layout that will be used by output audio buffers."]
    pub speakerLayout: IPLSpeakerLayout,
    #[doc = " The maximum Ambisonics order that will be used by input audio buffers."]
    pub maxOrder: IPLint32,
}
#[doc = " Parameters for applying an Ambisonics panning effect to an audio buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLAmbisonicsPanningEffectParams {
    #[doc = " Ambisonic order of the input buffer. May be less than the \\c maxOrder specified when creating the effect,"]
    #[doc = "in which case the effect will process fewer input channels, reducing CPU usage."]
    pub order: IPLint32,
}
extern "C" {
    #[doc = " Creates an Ambisonics panning effect."]
    #[doc = ""]
    #[doc = "\\param  context         The context used to initialize Steam Audio."]
    #[doc = "\\param  audioSettings   Global audio processing settings."]
    #[doc = "\\param  effectSettings  The settings to use when creating the Ambisonics panning effect."]
    #[doc = "\\param  effect          [out] The created Ambisonics panning effect."]
    #[doc = ""]
    #[doc = "\\return Status code indicating whether or not the operation succeeded."]
    pub fn iplAmbisonicsPanningEffectCreate(
        context: IPLContext,
        audioSettings: *mut IPLAudioSettings,
        effectSettings: *mut IPLAmbisonicsPanningEffectSettings,
        effect: *mut IPLAmbisonicsPanningEffect,
    ) -> IPLerror;
}
extern "C" {
    #[doc = " Retains an additional reference to an Ambisonics panning effect."]
    #[doc = ""]
    #[doc = "\\param  effect  The Ambisonics panning effect to retain a reference to."]
    #[doc = ""]
    #[doc = "\\return The additional reference to the Ambisonics panning effect."]
    pub fn iplAmbisonicsPanningEffectRetain(
        effect: IPLAmbisonicsPanningEffect,
    ) -> IPLAmbisonicsPanningEffect;
}
extern "C" {
    #[doc = " Releases a reference to an Ambisonics panning effect."]
    #[doc = ""]
    #[doc = "\\param  effect  The Ambisonics panning effect to release a reference to."]
    pub fn iplAmbisonicsPanningEffectRelease(effect: *mut IPLAmbisonicsPanningEffect);
}
extern "C" {
    #[doc = " Resets the internal processing state of an Ambisonics panning effect."]
    #[doc = ""]
    #[doc = "\\param  effect  The Ambisonics panning effect to reset."]
    pub fn iplAmbisonicsPanningEffectReset(effect: IPLAmbisonicsPanningEffect);
}
extern "C" {
    #[doc = " Applies an Ambisonics panning effect to an audio buffer."]
    #[doc = ""]
    #[doc = "This effect CANNOT be applied in-place."]
    #[doc = ""]
    #[doc = "\\param  effect  The Ambisonics panning effect to apply."]
    #[doc = "\\param  params  Parameters for applying the effect."]
    #[doc = "\\param  in      The input audio buffer. Must have as many channels as needed for the Ambisonics order"]
    #[doc = "specified in the parameters."]
    #[doc = "\\param  out     The output audio buffer. Must have as many channels as needed for the speaker layout"]
    #[doc = "specified when creating the effect."]
    #[doc = ""]
    #[doc = "\\return \\c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE to indicate that this effect does not generate any tail samples."]
    pub fn iplAmbisonicsPanningEffectApply(
        effect: IPLAmbisonicsPanningEffect,
        params: *mut IPLAmbisonicsPanningEffectParams,
        in_: *mut IPLAudioBuffer,
        out: *mut IPLAudioBuffer,
    ) -> IPLAudioEffectState;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IPLAmbisonicsBinauralEffect_t {
    _unused: [u8; 0],
}
pub type IPLAmbisonicsBinauralEffect = *mut _IPLAmbisonicsBinauralEffect_t;
#[doc = " Settings used to create an Ambisonics binaural effect."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLAmbisonicsBinauralEffectSettings {
    #[doc = " The HRTF to use."]
    pub hrtf: IPLHRTF,
    #[doc = " The maximum Ambisonics order that will be used by input audio buffers."]
    pub maxOrder: IPLint32,
}
#[doc = " Parameters for applying an Ambisonics binaural effect to an audio buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLAmbisonicsBinauralEffectParams {
    #[doc = " The HRTF to use."]
    pub hrtf: IPLHRTF,
    #[doc = " Ambisonic order of the input buffer. May be less than the \\c maxOrder specified when creating the effect,"]
    #[doc = "in which case the effect will process fewer input channels, reducing CPU usage."]
    pub order: IPLint32,
}
extern "C" {
    #[doc = " Creates an Ambisonics binaural effect."]
    #[doc = ""]
    #[doc = "\\param  context         The context used to initialize Steam Audio."]
    #[doc = "\\param  audioSettings   Global audio processing settings."]
    #[doc = "\\param  effectSettings  The settings to use when creating the Ambisonics binaural effect."]
    #[doc = "\\param  effect          [out] The created Ambisonics binaural effect."]
    #[doc = ""]
    #[doc = "\\return Status code indicating whether or not the operation succeeded."]
    pub fn iplAmbisonicsBinauralEffectCreate(
        context: IPLContext,
        audioSettings: *mut IPLAudioSettings,
        effectSettings: *mut IPLAmbisonicsBinauralEffectSettings,
        effect: *mut IPLAmbisonicsBinauralEffect,
    ) -> IPLerror;
}
extern "C" {
    #[doc = " Retains an additional reference to an Ambisonics binaural effect."]
    #[doc = ""]
    #[doc = "\\param  effect  The Ambisonics binaural effect to retain a reference to."]
    #[doc = ""]
    #[doc = "\\return The additional reference to the Ambisonics binaural effect."]
    pub fn iplAmbisonicsBinauralEffectRetain(
        effect: IPLAmbisonicsBinauralEffect,
    ) -> IPLAmbisonicsBinauralEffect;
}
extern "C" {
    #[doc = " Releases a reference to an Ambisonics binaural effect."]
    #[doc = ""]
    #[doc = "\\param  effect  The Ambisonics binaural effect to release a reference to."]
    pub fn iplAmbisonicsBinauralEffectRelease(effect: *mut IPLAmbisonicsBinauralEffect);
}
extern "C" {
    #[doc = " Resets the internal processing state of an Ambisonics binaural effect."]
    #[doc = ""]
    #[doc = "\\param  effect  The Ambisonics binaural effect to reset."]
    pub fn iplAmbisonicsBinauralEffectReset(effect: IPLAmbisonicsBinauralEffect);
}
extern "C" {
    #[doc = " Applies an Ambisonics binaural effect to an audio buffer."]
    #[doc = ""]
    #[doc = "This effect CANNOT be applied in-place."]
    #[doc = ""]
    #[doc = "\\param  effect  The Ambisonics binaural effect to apply."]
    #[doc = "\\param  params  Parameters for applying the effect."]
    #[doc = "\\param  in      The input audio buffer. Must have as many channels as needed for the Ambisonics order"]
    #[doc = "specified in the parameters."]
    #[doc = "\\param  out     The output audio buffer. Must have 2 channels."]
    #[doc = ""]
    #[doc = "\\return \\c IPL_AUDIOEFFECTSTATE_TAILREMAINING if any tail samples remain in the effect's internal buffers, or"]
    #[doc = "\\c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE otherwise."]
    pub fn iplAmbisonicsBinauralEffectApply(
        effect: IPLAmbisonicsBinauralEffect,
        params: *mut IPLAmbisonicsBinauralEffectParams,
        in_: *mut IPLAudioBuffer,
        out: *mut IPLAudioBuffer,
    ) -> IPLAudioEffectState;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IPLAmbisonicsRotationEffect_t {
    _unused: [u8; 0],
}
pub type IPLAmbisonicsRotationEffect = *mut _IPLAmbisonicsRotationEffect_t;
#[doc = " Settings used to create an Ambisonics rotation effect."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLAmbisonicsRotationEffectSettings {
    #[doc = " The maximum Ambisonics order that will be used by input audio buffers."]
    pub maxOrder: IPLint32,
}
#[doc = " Parameters for applying an Ambisonics rotation effect to an audio buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLAmbisonicsRotationEffectParams {
    #[doc = " The orientation of the listener."]
    pub orientation: IPLCoordinateSpace3,
    #[doc = " Ambisonic order of the input and output buffers. May be less than the \\c maxOrder specified when creating the"]
    #[doc = "effect, in which case the effect will process fewer channels, reducing CPU usage."]
    pub order: IPLint32,
}
extern "C" {
    #[doc = " Creates an Ambisonics rotation effect."]
    #[doc = ""]
    #[doc = "\\param  context         The context used to initialize Steam Audio."]
    #[doc = "\\param  audioSettings   Global audio processing settings."]
    #[doc = "\\param  effectSettings  The settings to use when creating the Ambisonics rotation effect."]
    #[doc = "\\param  effect          [out] The created Ambisonics rotation effect."]
    #[doc = ""]
    #[doc = "\\return Status code indicating whether or not the operation succeeded."]
    pub fn iplAmbisonicsRotationEffectCreate(
        context: IPLContext,
        audioSettings: *mut IPLAudioSettings,
        effectSettings: *mut IPLAmbisonicsRotationEffectSettings,
        effect: *mut IPLAmbisonicsRotationEffect,
    ) -> IPLerror;
}
extern "C" {
    #[doc = " Retains an additional reference to an Ambisonics rotation effect."]
    #[doc = ""]
    #[doc = "\\param  effect  The Ambisonics rotation effect to retain a reference to."]
    #[doc = ""]
    #[doc = "\\return The additional reference to the Ambisonics rotation effect."]
    pub fn iplAmbisonicsRotationEffectRetain(
        effect: IPLAmbisonicsRotationEffect,
    ) -> IPLAmbisonicsRotationEffect;
}
extern "C" {
    #[doc = " Releases a reference to an Ambisonics rotation effect."]
    #[doc = ""]
    #[doc = "\\param  effect  The Ambisonics rotation effect to release a reference to."]
    pub fn iplAmbisonicsRotationEffectRelease(effect: *mut IPLAmbisonicsRotationEffect);
}
extern "C" {
    #[doc = " Resets the internal processing state of an Ambisonics rotation effect."]
    #[doc = ""]
    #[doc = "\\param  effect  The Ambisonics rotation effect to reset."]
    pub fn iplAmbisonicsRotationEffectReset(effect: IPLAmbisonicsRotationEffect);
}
extern "C" {
    #[doc = " Applies an Ambisonics rotation effect to an audio buffer."]
    #[doc = ""]
    #[doc = "This effect CANNOT be applied in-place."]
    #[doc = ""]
    #[doc = "\\param  effect  The Ambisonics rotation effect to apply."]
    #[doc = "\\param  params  Parameters for applying the effect."]
    #[doc = "\\param  in      The input audio buffer. Must have as many channels as needed for the Ambisonics order"]
    #[doc = "specified when creating the effect."]
    #[doc = "\\param  out     The output audio buffer. Must have as many channels as needed for the Ambisonics order"]
    #[doc = "specified when creating the effect."]
    #[doc = ""]
    #[doc = "\\return \\c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE to indicate that this effect does not generate any tail samples."]
    pub fn iplAmbisonicsRotationEffectApply(
        effect: IPLAmbisonicsRotationEffect,
        params: *mut IPLAmbisonicsRotationEffectParams,
        in_: *mut IPLAudioBuffer,
        out: *mut IPLAudioBuffer,
    ) -> IPLAudioEffectState;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IPLAmbisonicsDecodeEffect_t {
    _unused: [u8; 0],
}
pub type IPLAmbisonicsDecodeEffect = *mut _IPLAmbisonicsDecodeEffect_t;
#[doc = " Settings used to create an Ambisonics decode effect."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLAmbisonicsDecodeEffectSettings {
    #[doc = " The speaker layout that will be used by output audio buffers."]
    pub speakerLayout: IPLSpeakerLayout,
    #[doc = " The HRTF to use."]
    pub hrtf: IPLHRTF,
    #[doc = " The maximum Ambisonics order that will be used by input audio buffers."]
    pub maxOrder: IPLint32,
}
#[doc = " Parameters for applying an Ambisonics decode effect to an audio buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLAmbisonicsDecodeEffectParams {
    #[doc = " Ambisonic order of the input buffer. May be less than the \\c maxOrder specified when creating the effect,"]
    #[doc = "in which case the effect will process fewer input channels, reducing CPU usage."]
    pub order: IPLint32,
    #[doc = " The HRTF to use."]
    pub hrtf: IPLHRTF,
    #[doc = " The orientation of the listener."]
    pub orientation: IPLCoordinateSpace3,
    #[doc = " Whether to use binaural rendering or panning."]
    pub binaural: IPLbool,
}
extern "C" {
    #[doc = " Creates an Ambisonics rotation effect."]
    #[doc = ""]
    #[doc = "\\param  context         The context used to initialize Steam Audio."]
    #[doc = "\\param  audioSettings   Global audio processing settings."]
    #[doc = "\\param  effectSettings  The settings to use when creating the Ambisonics rotation effect."]
    #[doc = "\\param  effect          [out] The created Ambisonics rotation effect."]
    #[doc = ""]
    #[doc = "\\return Status code indicating whether or not the operation succeeded."]
    pub fn iplAmbisonicsDecodeEffectCreate(
        context: IPLContext,
        audioSettings: *mut IPLAudioSettings,
        effectSettings: *mut IPLAmbisonicsDecodeEffectSettings,
        effect: *mut IPLAmbisonicsDecodeEffect,
    ) -> IPLerror;
}
extern "C" {
    #[doc = " Retains an additional reference to an Ambisonics rotation effect."]
    #[doc = ""]
    #[doc = "\\param  effect  The Ambisonics rotation effect to retain a reference to."]
    #[doc = ""]
    #[doc = "\\return The additional reference to the Ambisonics rotation effect."]
    pub fn iplAmbisonicsDecodeEffectRetain(
        effect: IPLAmbisonicsDecodeEffect,
    ) -> IPLAmbisonicsDecodeEffect;
}
extern "C" {
    #[doc = " Releases a reference to an Ambisonics rotation effect."]
    #[doc = ""]
    #[doc = "\\param  effect  The Ambisonics rotation effect to release a reference to."]
    pub fn iplAmbisonicsDecodeEffectRelease(effect: *mut IPLAmbisonicsDecodeEffect);
}
extern "C" {
    #[doc = " Resets the internal processing state of an Ambisonics rotation effect."]
    #[doc = ""]
    #[doc = "\\param  effect  The Ambisonics rotation effect to reset."]
    pub fn iplAmbisonicsDecodeEffectReset(effect: IPLAmbisonicsDecodeEffect);
}
extern "C" {
    #[doc = " Applies an Ambisonics decode effect to an audio buffer."]
    #[doc = ""]
    #[doc = "This effect CANNOT be applied in-place."]
    #[doc = ""]
    #[doc = "\\param  effect  The Ambisonics decode effect to apply."]
    #[doc = "\\param  params  Parameters for applying the effect."]
    #[doc = "\\param  in      The input audio buffer. Must have as many channels as needed for the Ambisonics order"]
    #[doc = "specified when creating the effect."]
    #[doc = "\\param  out     The output audio buffer. Must have as many channels as needed for the speaker layout"]
    #[doc = "specified when creating the effect (if using panning) or 2 channels (if using"]
    #[doc = "binaural rendering)."]
    #[doc = ""]
    #[doc = "\\return \\c IPL_AUDIOEFFECTSTATE_TAILREMAINING if any tail samples remain in the effect's internal buffers, or"]
    #[doc = "\\c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE otherwise."]
    pub fn iplAmbisonicsDecodeEffectApply(
        effect: IPLAmbisonicsDecodeEffect,
        params: *mut IPLAmbisonicsDecodeEffectParams,
        in_: *mut IPLAudioBuffer,
        out: *mut IPLAudioBuffer,
    ) -> IPLAudioEffectState;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IPLDirectEffect_t {
    _unused: [u8; 0],
}
pub type IPLDirectEffect = *mut _IPLDirectEffect_t;
bitflags!{
    #[doc = " Flags indicating which direct path parameters to apply."]
    #[repr(C)]
    pub struct IPLDirectEffectFlags: u32 {
                                     #[doc = " Apply frequency-independent distance attenuation."]
                                     const IPL_DIRECTEFFECTFLAGS_APPLYDISTANCEATTENUATION = 1;
                                     #[doc = " Apply frequency-dependent air absorption as a function of distance."]
                                     const IPL_DIRECTEFFECTFLAGS_APPLYAIRABSORPTION = 2;
                                     #[doc = " Apply attenuation due to source directivity pattern."]
                                     const IPL_DIRECTEFFECTFLAGS_APPLYDIRECTIVITY = 4;
                                     #[doc = " Apply occlusion."]
                                     const IPL_DIRECTEFFECTFLAGS_APPLYOCCLUSION = 8;
                                     #[doc = " Apply transmission along with occlusion."]
                                     const IPL_DIRECTEFFECTFLAGS_APPLYTRANSMISSION = 16;
    }
}
#[repr(i32)]
#[doc = " Modes of applying transmission effects."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IPLTransmissionType {
    #[doc = " Transmission is frequency-independent."]
    IPL_TRANSMISSIONTYPE_FREQINDEPENDENT = 0,
    #[doc = " Transmission is frequency-dependent."]
    IPL_TRANSMISSIONTYPE_FREQDEPENDENT = 1,
}
#[doc = " Settings used to create a direct effect."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLDirectEffectSettings {
    #[doc = " Number of channels that will be used by input and output buffers."]
    pub numChannels: IPLint32,
}
#[doc = " Parameters for applying a direct effect to an audio buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLDirectEffectParams {
    #[doc = " Flags indicating which direct path effects to apply."]
    pub flags: IPLDirectEffectFlags,
    #[doc = " Mode of applying transmission effect, if \\c IPL_DIRECTEFFECTFLAGS_APPLYTRANSMISSION is enabled."]
    pub transmissionType: IPLTransmissionType,
    #[doc = " Value of distance attenuation, between 0 and 1."]
    pub distanceAttenuation: IPLfloat32,
    #[doc = " 3-band EQ coefficients for air absorption, each between 0 and 1."]
    pub airAbsorption: [IPLfloat32; 3usize],
    #[doc = " Value of directivity term, between 0 and 1."]
    pub directivity: IPLfloat32,
    #[doc = " Value of occlusion factor, between 0 and 1."]
    pub occlusion: IPLfloat32,
    #[doc = " 3-band EQ coefficients for transmission, each between 0 and 1."]
    pub transmission: [IPLfloat32; 3usize],
}
extern "C" {
    #[doc = " Creates a direct effect."]
    #[doc = ""]
    #[doc = "\\param  context         The context used to initialize Steam Audio."]
    #[doc = "\\param  audioSettings   Global audio processing settings."]
    #[doc = "\\param  effectSettings  The settings to use when creating the direct effect."]
    #[doc = "\\param  effect          [out] The created direct effect."]
    #[doc = ""]
    #[doc = "\\return Status code indicating whether or not the operation succeeded."]
    pub fn iplDirectEffectCreate(
        context: IPLContext,
        audioSettings: *mut IPLAudioSettings,
        effectSettings: *mut IPLDirectEffectSettings,
        effect: *mut IPLDirectEffect,
    ) -> IPLerror;
}
extern "C" {
    #[doc = " Retains an additional reference to a direct effect."]
    #[doc = ""]
    #[doc = "\\param  effect  The direct effect to retain a reference to."]
    #[doc = ""]
    #[doc = "\\return The additional reference to the direct effect."]
    pub fn iplDirectEffectRetain(effect: IPLDirectEffect) -> IPLDirectEffect;
}
extern "C" {
    #[doc = " Releases a reference to a direct effect."]
    #[doc = ""]
    #[doc = "\\param  effect  The direct effect to release a reference to."]
    pub fn iplDirectEffectRelease(effect: *mut IPLDirectEffect);
}
extern "C" {
    #[doc = " Resets the internal processing state of a direct effect."]
    #[doc = ""]
    #[doc = "\\param  effect  The direct effect to reset."]
    pub fn iplDirectEffectReset(effect: IPLDirectEffect);
}
extern "C" {
    #[doc = " Applies a direct effect to an audio buffer."]
    #[doc = ""]
    #[doc = "This effect CAN be applied in-place."]
    #[doc = ""]
    #[doc = "\\param  effect  The direct effect to apply."]
    #[doc = "\\param  params  Parameters for applying the effect."]
    #[doc = "\\param  in      The input audio buffer. Must have as many channels as specified when creating the effect."]
    #[doc = "\\param  out     The output audio buffer. Must have as many channels as specified when creating the effect."]
    #[doc = ""]
    #[doc = "\\return \\c IPL_AUDIOEFFECTSTATE_TAILREMAINING if any tail samples remain in the effect's internal buffers, or"]
    #[doc = "\\c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE otherwise."]
    pub fn iplDirectEffectApply(
        effect: IPLDirectEffect,
        params: *mut IPLDirectEffectParams,
        in_: *mut IPLAudioBuffer,
        out: *mut IPLAudioBuffer,
    ) -> IPLAudioEffectState;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IPLReflectionEffectIR_t {
    _unused: [u8; 0],
}
pub type IPLReflectionEffectIR = *mut _IPLReflectionEffectIR_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IPLReflectionEffect_t {
    _unused: [u8; 0],
}
pub type IPLReflectionEffect = *mut _IPLReflectionEffect_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IPLReflectionMixer_t {
    _unused: [u8; 0],
}
pub type IPLReflectionMixer = *mut _IPLReflectionMixer_t;
#[repr(i32)]
#[doc = " Type of reflection effect algorithm to use."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IPLReflectionEffectType {
    #[doc = " Multi-channel convolution reverb. Reflections reaching the listener are encoded in an Impulse Response (IR),"]
    #[doc = "which is a filter that records each reflection as it arrives. This algorithm renders reflections with the most"]
    #[doc = "detail, but may result in significant CPU usage. Using a reflection mixer with this algorithm provides a"]
    #[doc = "reduction in CPU usage."]
    IPL_REFLECTIONEFFECTTYPE_CONVOLUTION = 0,
    #[doc = " Parametric (or artificial) reverb, using feedback delay networks. The reflected sound field is reduced to a few"]
    #[doc = "numbers that describe how reflected energy decays over time. This is then used to drive an approximate model"]
    #[doc = "of reverberation in an indoor space. This algorithm results in lower CPU usage, but cannot render individual"]
    #[doc = "echoes, especially in outdoor spaces. A reflection mixer cannot be used with this algorithm."]
    IPL_REFLECTIONEFFECTTYPE_PARAMETRIC = 1,
    #[doc = " A hybrid of convolution and parametric reverb. The initial portion of the IR is rendered using convolution"]
    #[doc = "reverb, but the later part is used to estimate a parametric reverb. The point in the IR where this transition"]
    #[doc = "occurs can be controlled. This algorithm allows a trade-off between rendering quality and CPU usage. An"]
    #[doc = "reflection mixer cannot be used with this algorithm."]
    IPL_REFLECTIONEFFECTTYPE_HYBRID = 2,
    #[doc = " Multi-channel convolution reverb, using AMD TrueAudio Next for GPU acceleration. This algorithm is similar"]
    #[doc = "to \\c IPL_REFLECTIONEFFECTYPE_CONVOLUTION, but uses the GPU instead of the CPU for processing, allowing"]
    #[doc = "significantly more sources to be processed. A reflection mixer must be used with this algorithm, because"]
    #[doc = "the GPU will process convolution reverb at a single point in your audio processing pipeline."]
    IPL_REFLECTIONEFFECTTYPE_TAN = 3,
}
#[doc = " Settings used to create a reflection effect."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLReflectionEffectSettings {
    #[doc = " Type of reflection effect algorithm to use."]
    pub type_: IPLReflectionEffectType,
    #[doc = " Number of samples per channel in the IR."]
    pub irSize: IPLint32,
    #[doc = " Number of channels in the IR."]
    pub numChannels: IPLint32,
}
#[doc = " Parameters for applying a reflection effect to an audio buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLReflectionEffectParams {
    #[doc = " Type of reflection effect algorithm to use."]
    pub type_: IPLReflectionEffectType,
    #[doc = " The impulse response. For \\c IPL_REFLECTIONEFFECTTYPE_CONVOLUTION or \\c IPL_REFLECTIONEFFECTTYPE_HYBRID."]
    pub ir: IPLReflectionEffectIR,
    #[doc = " 3-band reverb decay times (RT60). For \\c IPL_REFLECTIONEFFECTTYPE_PARAMETRIC or"]
    #[doc = "\\c IPL_REFLECTIONEFFECTTYPE_HYBRID."]
    pub reverbTimes: [IPLfloat32; 3usize],
    #[doc = " 3-band EQ coefficients applied to the parametric part to ensure smooth transition."]
    #[doc = "For \\c IPL_REFLECTIONEFFECTTYPE_HYBRID."]
    pub eq: [IPLfloat32; 3usize],
    #[doc = " Samples after which parametric part starts. For \\c IPL_REFLECTIONEFFECTTYPE_HYBRID."]
    pub delay: IPLint32,
    #[doc = " Number of IR channels to process. May be less than the number of channels specified when creating the effect,"]
    #[doc = "in which case CPU usage will be reduced."]
    pub numChannels: IPLint32,
    #[doc = " Number of IR samples per channel to process. May be less than the number of samples specified when creating"]
    #[doc = "the effect, in which case CPU usage will be reduced."]
    pub irSize: IPLint32,
    #[doc = " The TrueAudio Next device to use for convolution processing. For \\c IPL_REFLECTIONEFFECTTYPE_TAN."]
    pub tanDevice: IPLTrueAudioNextDevice,
    #[doc = " The TrueAudio Next slot index to use for convolution processing. The slot identifies the IR to use. For"]
    #[doc = "\\c IPL_REFLECTIONEFFECTTYPE_TAN."]
    pub tanSlot: IPLint32,
}
extern "C" {
    #[doc = " Creates a reflection effect."]
    #[doc = ""]
    #[doc = "\\param  context         The context used to initialize Steam Audio."]
    #[doc = "\\param  audioSettings   Global audio processing settings."]
    #[doc = "\\param  effectSettings  The settings to use when creating the reflection effect."]
    #[doc = "\\param  effect          [out] The created reflection effect."]
    #[doc = ""]
    #[doc = "\\return Status code indicating whether or not the operation succeeded."]
    pub fn iplReflectionEffectCreate(
        context: IPLContext,
        audioSettings: *mut IPLAudioSettings,
        effectSettings: *mut IPLReflectionEffectSettings,
        effect: *mut IPLReflectionEffect,
    ) -> IPLerror;
}
extern "C" {
    #[doc = " Retains an additional reference to a reflection effect."]
    #[doc = ""]
    #[doc = "\\param  effect  The reflection effect to retain a reference to."]
    #[doc = ""]
    #[doc = "\\return The additional reference to the reflection effect."]
    pub fn iplReflectionEffectRetain(effect: IPLReflectionEffect) -> IPLReflectionEffect;
}
extern "C" {
    #[doc = " Releases a reference to a reflection effect."]
    #[doc = ""]
    #[doc = "\\param  effect  The reflection effect to release a reference to."]
    pub fn iplReflectionEffectRelease(effect: *mut IPLReflectionEffect);
}
extern "C" {
    #[doc = " Resets the internal processing state of a reflection effect."]
    #[doc = ""]
    #[doc = "\\param  effect  The reflection effect to reset."]
    pub fn iplReflectionEffectReset(effect: IPLReflectionEffect);
}
extern "C" {
    #[doc = " Applies a reflection effect to an audio buffer."]
    #[doc = ""]
    #[doc = "This effect CANNOT be applied in-place."]
    #[doc = ""]
    #[doc = "\\param  effect  The reflection effect to apply."]
    #[doc = "\\param  params  Parameters for applying the effect."]
    #[doc = "\\param  in      The input audio buffer. Must have 1 channel."]
    #[doc = "\\param  out     The output audio buffer. Must have as many channels as the impulse response"]
    #[doc = "specified when creating the effect (for convolution, hybrid, and TAN) or at"]
    #[doc = "least 1 channel (for parametric)."]
    #[doc = "\\param  mixer   If this is non-null, then the output of this effect will be mixed into the given"]
    #[doc = "mixer object instead of being returned in the \\c out parameter. The mixed output can"]
    #[doc = "be retrieved elsewhere in the audio pipeline using \\c iplReflectionMixerApply. This"]
    #[doc = "can have a performance benefit if using convolution. If using TAN, specifying"]
    #[doc = "a mixer is required."]
    #[doc = ""]
    #[doc = "\\return \\c IPL_AUDIOEFFECTSTATE_TAILREMAINING if any tail samples remain in the effect's internal buffers, or"]
    #[doc = "\\c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE otherwise."]
    pub fn iplReflectionEffectApply(
        effect: IPLReflectionEffect,
        params: *mut IPLReflectionEffectParams,
        in_: *mut IPLAudioBuffer,
        out: *mut IPLAudioBuffer,
        mixer: IPLReflectionMixer,
    ) -> IPLAudioEffectState;
}
extern "C" {
    #[doc = " Creates a reflection effect mixer."]
    #[doc = ""]
    #[doc = "\\param  context         The context used to initialize Steam Audio."]
    #[doc = "\\param  audioSettings   Global audio processing settings."]
    #[doc = "\\param  effectSettings  The settings used when creating the reflection effects that will be mixed into"]
    #[doc = "this reflection mixer."]
    #[doc = "\\param  mixer           [out] The created reflection mixer."]
    #[doc = ""]
    #[doc = "\\return Status code indicating whether or not the operation succeeded."]
    pub fn iplReflectionMixerCreate(
        context: IPLContext,
        audioSettings: *mut IPLAudioSettings,
        effectSettings: *mut IPLReflectionEffectSettings,
        mixer: *mut IPLReflectionMixer,
    ) -> IPLerror;
}
extern "C" {
    #[doc = " Retains an additional reference to a reflection mixer."]
    #[doc = ""]
    #[doc = "\\param  mixer   The reflection mixer to retain a reference to."]
    #[doc = ""]
    #[doc = "\\return The additional reference to the reflection mixer."]
    pub fn iplReflectionMixerRetain(mixer: IPLReflectionMixer) -> IPLReflectionMixer;
}
extern "C" {
    #[doc = " Releases a reference to a reflection mixer."]
    #[doc = ""]
    #[doc = "\\param  mixer   The reflection mixer to release a reference to."]
    pub fn iplReflectionMixerRelease(mixer: *mut IPLReflectionMixer);
}
extern "C" {
    #[doc = " Resets the internal processing state of a reflection mixer."]
    #[doc = ""]
    #[doc = "\\param  mixer   The reflection mixer to reset."]
    pub fn iplReflectionMixerReset(mixer: IPLReflectionMixer);
}
extern "C" {
    #[doc = " Retrieves the contents of a reflection mixer and places it into an audio buffer."]
    #[doc = ""]
    #[doc = "\\param  mixer   The reflection mixer to retrieve audio from."]
    #[doc = "\\param  params  Parameters for applying the effect."]
    #[doc = "\\param  out     The output audio buffer. Must have as many channels as the impulse response"]
    #[doc = "specified when creating the mixer."]
    #[doc = ""]
    #[doc = "\\return \\c IPL_AUDIOEFFECTSTATE_TAILREMAINING if any tail samples remain in the effect's internal buffers, or"]
    #[doc = "\\c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE otherwise."]
    pub fn iplReflectionMixerApply(
        mixer: IPLReflectionMixer,
        params: *mut IPLReflectionEffectParams,
        out: *mut IPLAudioBuffer,
    ) -> IPLAudioEffectState;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IPLPathEffect_t {
    _unused: [u8; 0],
}
pub type IPLPathEffect = *mut _IPLPathEffect_t;
#[doc = " Settings used to create a path effect."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLPathEffectSettings {
    #[doc = " The maximum Ambisonics order that will be used by output audio buffers."]
    pub maxOrder: IPLint32,
}
#[doc = " Parameters for applying a path effect to an audio buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLPathEffectParams {
    #[doc = " 3-band EQ coefficients for modeling frequency-dependent attenuation caused by paths bending around"]
    #[doc = "obstacles."]
    pub eqCoeffs: [IPLfloat32; 3usize],
    #[doc = " Ambisonic coefficients for modeling the directional distribution of sound reaching the listener."]
    #[doc = "The coefficients are specified in world-space, and must be rotated to match the listener's orientation"]
    #[doc = "separately."]
    pub shCoeffs: *mut IPLfloat32,
    #[doc = " Ambisonic order of the output buffer. May be less than the maximum order specified when creating the effect,"]
    #[doc = "in which case higher-order \\c shCoeffs will be ignored, and CPU usage will be reduced."]
    pub order: IPLint32,
}
extern "C" {
    #[doc = " Creates a path effect."]
    #[doc = ""]
    #[doc = "\\param  context         The context used to initialize Steam Audio."]
    #[doc = "\\param  audioSettings   Global audio processing settings."]
    #[doc = "\\param  effectSettings  The settings to use when creating the path effect."]
    #[doc = "\\param  effect          [out] The created path effect."]
    #[doc = ""]
    #[doc = "\\return Status code indicating whether or not the operation succeeded."]
    pub fn iplPathEffectCreate(
        context: IPLContext,
        audioSettings: *mut IPLAudioSettings,
        effectSettings: *mut IPLPathEffectSettings,
        effect: *mut IPLPathEffect,
    ) -> IPLerror;
}
extern "C" {
    #[doc = " Retains an additional reference to a path effect."]
    #[doc = ""]
    #[doc = "\\param  effect  The path effect to retain a reference to."]
    #[doc = ""]
    #[doc = "\\return The additional reference to the path effect."]
    pub fn iplPathEffectRetain(effect: IPLPathEffect) -> IPLPathEffect;
}
extern "C" {
    #[doc = " Releases a reference to a path effect."]
    #[doc = ""]
    #[doc = "\\param  effect  The path effect to release a reference to."]
    pub fn iplPathEffectRelease(effect: *mut IPLPathEffect);
}
extern "C" {
    #[doc = " Resets the internal processing state of a path effect."]
    #[doc = ""]
    #[doc = "\\param  effect  The path effect to reset."]
    pub fn iplPathEffectReset(effect: IPLPathEffect);
}
extern "C" {
    #[doc = " Applies a path effect to an audio buffer."]
    #[doc = ""]
    #[doc = "This effect CANNOT be applied in-place."]
    #[doc = ""]
    #[doc = "\\param  effect  The path effect to apply."]
    #[doc = "\\param  params  Parameters for applying the effect."]
    #[doc = "\\param  in      The input audio buffer. Must have 1 channel."]
    #[doc = "\\param  out     The output audio buffer. Must have as many channels as needed for the"]
    #[doc = "Ambisonics order specified when creating the effect."]
    #[doc = ""]
    #[doc = "\\return \\c IPL_AUDIOEFFECTSTATE_TAILREMAINING if any tail samples remain in the effect's internal buffers, or"]
    #[doc = "\\c IPL_AUDIOEFFECTSTATE_TAILCOMPLETE otherwise."]
    pub fn iplPathEffectApply(
        effect: IPLPathEffect,
        params: *mut IPLPathEffectParams,
        in_: *mut IPLAudioBuffer,
        out: *mut IPLAudioBuffer,
    ) -> IPLAudioEffectState;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IPLProbeArray_t {
    _unused: [u8; 0],
}
pub type IPLProbeArray = *mut _IPLProbeArray_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IPLProbeBatch_t {
    _unused: [u8; 0],
}
pub type IPLProbeBatch = *mut _IPLProbeBatch_t;
#[repr(i32)]
#[doc = " The different algorithms for generating probes."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IPLProbeGenerationType {
    #[doc = " Generates a single probe at the center of the specified box."]
    IPL_PROBEGENERATIONTYPE_CENTROID = 0,
    #[doc = " Generates probes that are uniformly-spaced, at a fixed height above solid geometry. A probe will never be"]
    #[doc = "generated above another probe unless there is a solid object between them. The goal is to model floors or"]
    #[doc = "terrain, and generate probes that are a fixed height above the floor or terrain, and uniformly-spaced along"]
    #[doc = "the horizontal plane. This algorithm is not suitable for scenarios where the listener may fly into a region"]
    #[doc = "with no probes; if this happens, the listener will not be influenced by any of the baked data."]
    IPL_PROBEGENERATIONTYPE_UNIFORMFLOOR = 1,
}
#[repr(i32)]
#[doc = " The different ways in which the source and listener positions used to generate baked data can vary as a function"]
#[doc = "of probe position."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IPLBakedDataVariation {
    #[doc = " At each probe, baked data is calculated with both the source and the listener at the probe position. This"]
    #[doc = "is useful for modeling traditional reverbs, which depend only on the listener's position (or only on the"]
    #[doc = "source's position)."]
    IPL_BAKEDDATAVARIATION_REVERB = 0,
    #[doc = " At each probe, baked data is calculated with the source at some fixed position (specified separately),"]
    #[doc = "and the listener at the probe position. This is used for modeling reflections from a static source to any"]
    #[doc = "point within the probe batch."]
    IPL_BAKEDDATAVARIATION_STATICSOURCE = 1,
    #[doc = " At each probe, baked data is calculated with the source at the probe position, and the listener at some"]
    #[doc = "fixed position (specified separately). This is used for modeling reflections from a moving source to a"]
    #[doc = "static listener."]
    IPL_BAKEDDATAVARIATION_STATICLISTENER = 2,
    #[doc = " Baked data is calculated for each pair of probes. For example, this is used for calculating paths between"]
    #[doc = "every pair of probes in a batch."]
    IPL_BAKEDDATAVARIATION_DYNAMIC = 3,
}
#[repr(i32)]
#[doc = " The types of baked data that can be stored in a probe batch."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IPLBakedDataType {
    #[doc = " Reflections. The source and listener positions used to compute the reflections data stored at each probe"]
    #[doc = "depends on the \\c IPLBakedDataVariation selected."]
    IPL_BAKEDDATATYPE_REFLECTIONS = 0,
    #[doc = " Pathing. The probe batch stores data about the shortest paths between any pair of probes in the batch."]
    IPL_BAKEDDATATYPE_PATHING = 1,
}
#[doc = " Settings used to generate probes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLProbeGenerationParams {
    #[doc = " The algorithm to use for generating probes."]
    pub type_: IPLProbeGenerationType,
    #[doc = " Spacing (in meters) between two neighboring probes. Only for \\c IPL_PROBEGENERATIONTYPE_UNIFORMFLOOR."]
    pub spacing: IPLfloat32,
    #[doc = " Height (in meters) above the floor at which probes will be generated. Only for"]
    #[doc = "\\c IPL_PROBEGENERATIONTYPE_UNIFORMFLOOR."]
    pub height: IPLfloat32,
    #[doc = " A transformation matrix that transforms an axis-aligned unit cube, with minimum and maximum vertices"]
    #[doc = "at (0, 0, 0) and (1, 1, 1), into a parallelopiped volume. Probes will be generated within this"]
    #[doc = "volume."]
    pub transform: IPLMatrix4x4,
}
#[doc = " Identifies a \"layer\" of data stored in a probe batch. Each probe batch may store multiple layers of data,"]
#[doc = "such as reverb, static source reflections, or pathing. Each layer can be accessed using an identifier."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLBakedDataIdentifier {
    #[doc = " The type of data stored."]
    pub type_: IPLBakedDataType,
    #[doc = " The way in which source and listener positions depend on probe position."]
    pub variation: IPLBakedDataVariation,
    #[doc = " The static source (for \\c IPL_BAKEDDATAVARIATION_STATICSOURCE) or static listener (for"]
    #[doc = "\\c IPL_BAKEDDATAVARIATION_STATICLISTENER) used to generate baked data. Baked data is only stored for"]
    #[doc = "probes that lie within the radius of this sphere."]
    pub endpointInfluence: IPLSphere,
}
extern "C" {
    #[doc = " Creates an empty probe array."]
    #[doc = ""]
    #[doc = "\\param  context     The context used to initialize Steam Audio."]
    #[doc = "\\param  probeArray  [out] The created probe array."]
    #[doc = ""]
    #[doc = "\\return Status code indicating whether or not the operation succeeded."]
    pub fn iplProbeArrayCreate(context: IPLContext, probeArray: *mut IPLProbeArray) -> IPLerror;
}
extern "C" {
    #[doc = " Retains an additional reference to a probe array."]
    #[doc = ""]
    #[doc = "\\param  probeArray  The probe array to retain a reference to."]
    #[doc = ""]
    #[doc = "\\return The additional reference to the probe array."]
    pub fn iplProbeArrayRetain(probeArray: IPLProbeArray) -> IPLProbeArray;
}
extern "C" {
    #[doc = " Releases a reference to a probe array."]
    #[doc = ""]
    #[doc = "\\param  probeArray  The probe array to release a reference to."]
    pub fn iplProbeArrayRelease(probeArray: *mut IPLProbeArray);
}
extern "C" {
    #[doc = " Generates probes and adds them to a probe array."]
    #[doc = ""]
    #[doc = "\\param  scene       The scene in which to generate probes."]
    #[doc = "\\param  params      Parameters to use for generating probes."]
    #[doc = "\\param  probeArray  The array into which to add the generated probes."]
    pub fn iplProbeArrayGenerateProbes(
        probeArray: IPLProbeArray,
        scene: IPLScene,
        params: *mut IPLProbeGenerationParams,
    );
}
extern "C" {
    #[doc = " \\return The number of probes in a probe array."]
    #[doc = ""]
    #[doc = "\\param  probeArray  The probe array."]
    pub fn iplProbeArrayGetNumProbes(probeArray: IPLProbeArray) -> IPLint32;
}
extern "C" {
    #[doc = " \\return The probe at a given index in a probe array."]
    #[doc = ""]
    #[doc = "\\param  probeArray  The probe array."]
    #[doc = "\\param  index       Index of the probe within the array."]
    pub fn iplProbeArrayGetProbe(probeArray: IPLProbeArray, index: IPLint32) -> IPLSphere;
}
extern "C" {
    #[doc = " Creates an empty probe batch."]
    #[doc = ""]
    #[doc = "\\param  context     The context used to initialize Steam Audio."]
    #[doc = "\\param  probeBatch  [out] The created probe batch."]
    #[doc = ""]
    #[doc = "\\return Status code indicating whether or not the operation succeeded."]
    pub fn iplProbeBatchCreate(context: IPLContext, probeBatch: *mut IPLProbeBatch) -> IPLerror;
}
extern "C" {
    #[doc = " Retains an additional reference to a probe batch."]
    #[doc = ""]
    #[doc = "\\param  probeBatch  The probe batch to retain a reference to."]
    #[doc = ""]
    #[doc = "\\return The additional reference to the probe batch."]
    pub fn iplProbeBatchRetain(probeBatch: IPLProbeBatch) -> IPLProbeBatch;
}
extern "C" {
    #[doc = " Releases a reference to a probe batch."]
    #[doc = ""]
    #[doc = "\\param  probeBatch  The probe batch to release a reference to."]
    pub fn iplProbeBatchRelease(probeBatch: *mut IPLProbeBatch);
}
extern "C" {
    #[doc = " Loads a probe batch from a serialized object. Typically, the serialized object will be created from a byte array"]
    #[doc = "loaded from disk or over the network."]
    #[doc = ""]
    #[doc = "\\param  context             The context used to initialize Steam Audio."]
    #[doc = "\\param  serializedObject    The serialized object from which to load the probe batch."]
    #[doc = "\\param  probeBatch          [out] The created probe batch."]
    #[doc = ""]
    #[doc = "\\return Status code indicating whether or not the operation succeeded."]
    pub fn iplProbeBatchLoad(
        context: IPLContext,
        serializedObject: IPLSerializedObject,
        probeBatch: *mut IPLProbeBatch,
    ) -> IPLerror;
}
extern "C" {
    #[doc = " Saves a probe batch to a serialized object. Typically, the serialized object will then be saved to disk."]
    #[doc = ""]
    #[doc = "\\param  probeBatch          The probe batch to save."]
    #[doc = "\\param  serializedObject    The serialized object into which to save the probe batch."]
    pub fn iplProbeBatchSave(probeBatch: IPLProbeBatch, serializedObject: IPLSerializedObject);
}
extern "C" {
    #[doc = " \\return The number of probes in a probe batch."]
    #[doc = ""]
    #[doc = "\\param  probeBatch  The probe batch."]
    pub fn iplProbeBatchGetNumProbes(probeBatch: IPLProbeBatch) -> IPLint32;
}
extern "C" {
    #[doc = " Adds a probe to a batch. The new probe will be added as the last probe in the batch."]
    #[doc = ""]
    #[doc = "\\param  probeBatch  The probe batch."]
    #[doc = "\\param  probe       The probe to add."]
    pub fn iplProbeBatchAddProbe(probeBatch: IPLProbeBatch, probe: IPLSphere);
}
extern "C" {
    #[doc = " Adds every probe in an array to a batch. The new probes will be added, in order, at the end of the batch."]
    #[doc = ""]
    #[doc = "\\param  probeBatch  The probe batch."]
    #[doc = "\\param  probeArray  The probe array containing the probes to add."]
    pub fn iplProbeBatchAddProbeArray(probeBatch: IPLProbeBatch, probeArray: IPLProbeArray);
}
extern "C" {
    #[doc = " Removes a probe from a batch."]
    #[doc = ""]
    #[doc = "\\param  probeBatch  The probe batch."]
    #[doc = "\\param  index       Index of the probe to remove."]
    pub fn iplProbeBatchRemoveProbe(probeBatch: IPLProbeBatch, index: IPLint32);
}
extern "C" {
    #[doc = " Commits all changes made to a probe batch since this function was last called (or since the probe batch was"]
    #[doc = "first created, if this function was never called). This function must be called after adding, removing, or"]
    #[doc = "updating any probes in the batch, for the changes to take effect."]
    #[doc = ""]
    #[doc = "\\param  probeBatch  The probe batch."]
    pub fn iplProbeBatchCommit(probeBatch: IPLProbeBatch);
}
extern "C" {
    #[doc = " Deletes a specific layer of data from a probe batch."]
    #[doc = ""]
    #[doc = "\\param  probeBatch  The probe batch."]
    #[doc = "\\param  identifier  The identifier of the baked data layer to delete."]
    pub fn iplProbeBatchRemoveData(
        probeBatch: IPLProbeBatch,
        identifier: *mut IPLBakedDataIdentifier,
    );
}
extern "C" {
    #[doc = " \\return The size (in bytes) of a specific baked data layer in a probe batch."]
    #[doc = ""]
    #[doc = "\\param  probeBatch  The probe batch."]
    #[doc = "\\param  identifier  The identifier of the baked data layer."]
    pub fn iplProbeBatchGetDataSize(
        probeBatch: IPLProbeBatch,
        identifier: *mut IPLBakedDataIdentifier,
    ) -> IPLsize;
}
#[repr(i32)]
#[doc = " Flags for specifying what types of reflections data to bake."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IPLReflectionsBakeFlags {
    #[doc = " Bake impulse responses for \\c IPL_REFLECTIONEFFECTTYPE_CONVOLUTION, \\c IPL_REFLECTIONEFFECTTYPE_HYBRID,"]
    #[doc = "or \\c IPL_REFLECTIONEFFECTTYPE_TAN."]
    IPL_REFLECTIONSBAKEFLAGS_BAKECONVOLUTION = 1,
    #[doc = " Bake parametric reverb for \\c IPL_REFLECTIONEFFECTTYPE_PARAMETRIC or \\c IPL_REFLECTIONEFFECTTYPE_HYBRID."]
    IPL_REFLECTIONSBAKEFLAGS_BAKEPARAMETRIC = 2,
}
#[doc = " Parameters used to control how reflections data is baked."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLReflectionsBakeParams {
    #[doc = " The scene in which the probes exist."]
    pub scene: IPLScene,
    #[doc = " A probe batch containing the probes at which reflections data should be baked."]
    pub probeBatch: IPLProbeBatch,
    #[doc = " The type of scene being used."]
    pub sceneType: IPLSceneType,
    #[doc = " An identifier for the data layer that should be baked. The identifier determines what data is simulated and"]
    #[doc = "stored at each probe. If the probe batch already contains data with this identifier, it will be overwritten."]
    pub identifier: IPLBakedDataIdentifier,
    #[doc = " The types of data to save for each probe."]
    pub bakeFlags: IPLReflectionsBakeFlags,
    #[doc = " The number of rays to trace from each listener position when baking. Increasing this number results in"]
    #[doc = "improved accuracy, at the cost of increased bake times."]
    pub numRays: IPLint32,
    #[doc = " The number of directions to consider when generating diffusely-reflected rays when baking. Increasing"]
    #[doc = "this number results in slightly improved accuracy of diffuse reflections."]
    pub numDiffuseSamples: IPLint32,
    #[doc = " The number of times each ray is reflected off of solid geometry. Increasing this number results in"]
    #[doc = "longer reverb tails and improved accuracy, at the cost of increased bake times."]
    pub numBounces: IPLint32,
    #[doc = " The length (in seconds) of the impulse responses to simulate. Increasing this number allows the baked"]
    #[doc = "data to represent longer reverb tails (and hence larger spaces), at the cost of increased memory"]
    #[doc = "usage while baking."]
    pub simulatedDuration: IPLfloat32,
    #[doc = " The length (in seconds) of the impulse responses to save at each probe. Increasing this number allows"]
    #[doc = "the baked data to represent longer reverb tails (and hence larger spaces), at the cost of increased"]
    #[doc = "disk space usage and memory usage at run-time."]
    #[doc = ""]
    #[doc = "It may be useful to set \\c savedDuration to be less than \\c simulatedDuration, especially if you plan"]
    #[doc = "to use hybrid reverb for rendering baked reflections. This way, the parametric reverb data is"]
    #[doc = "estimated using a longer IR, resulting in more accurate estimation, but only the early part of the IR"]
    #[doc = "can be saved for subsequent rendering."]
    pub savedDuration: IPLfloat32,
    #[doc = " Ambisonic order of the baked IRs."]
    pub order: IPLint32,
    #[doc = " Number of threads to use for baking."]
    pub numThreads: IPLint32,
    #[doc = " If using custom ray tracer callbacks, this the number of rays that will be passed to the callbacks"]
    #[doc = "every time rays need to be traced."]
    pub rayBatchSize: IPLint32,
    #[doc = " When calculating how much sound energy reaches a surface directly from a source, any source that is"]
    #[doc = "closer than \\c irradianceMinDistance to the surface is assumed to be at a distance of"]
    #[doc = "\\c irradianceMinDistance, for the purposes of energy calculations."]
    pub irradianceMinDistance: IPLfloat32,
    #[doc = " If using Radeon Rays, this is the number of probes for which data is baked simultaneously."]
    pub bakeBatchSize: IPLint32,
    #[doc = " The OpenCL device, if using Radeon Rays."]
    pub openCLDevice: IPLOpenCLDevice,
    #[doc = " The Radeon Rays device, if using Radeon Rays."]
    pub radeonRaysDevice: IPLRadeonRaysDevice,
}
#[doc = " Parameters used to control how pathing data is baked."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLPathBakeParams {
    #[doc = " The scene in which the probes exist."]
    pub scene: IPLScene,
    #[doc = " A probe batch containing the probes for which pathing data should be baked."]
    pub probeBatch: IPLProbeBatch,
    #[doc = " An identifier for the data layer that should be baked. The identifier determines what data is simulated and"]
    #[doc = "stored at each probe. If the probe batch already contains data with this identifier, it will be overwritten."]
    pub identifier: IPLBakedDataIdentifier,
    #[doc = " Number of point samples to use around each probe when testing whether one probe can see another. To"]
    #[doc = "determine if two probes are mutually visible, numSamples * numSamples rays are traced, from each"]
    #[doc = "point sample of the first probe, to every other point sample of the second probe."]
    pub numSamples: IPLint32,
    #[doc = " When testing for mutual visibility between a pair of probes, each probe is treated as a sphere of"]
    #[doc = "this radius (in meters), and point samples are generated within this sphere."]
    pub radius: IPLfloat32,
    #[doc = " When tracing rays to test for mutual visibility between a pair of probes, the fraction of rays that"]
    #[doc = "are unoccluded must be greater than this threshold for the pair of probes to be considered"]
    #[doc = "mutually visible."]
    pub threshold: IPLfloat32,
    #[doc = " If the distance between two probes is greater than this value, the probes are not considered mutually"]
    #[doc = "visible. Increasing this value can result in simpler paths, at the cost of increased bake times."]
    pub visRange: IPLfloat32,
    #[doc = " If the distance between two probes is greater than this value, the probes are considered to"]
    #[doc = "not have any path between them. Increasing this value allows sound to propagate over greater"]
    #[doc = "distances, at the cost of increased bake times and memory usage."]
    pub pathRange: IPLfloat32,
    #[doc = " Number of threads to use for baking."]
    pub numThreads: IPLint32,
}
extern "C" {
    #[doc = " Bakes a single layer of reflections data in a probe batch."]
    #[doc = ""]
    #[doc = "Only one bake can be in progress at any point in time."]
    #[doc = ""]
    #[doc = "\\param  context             The context used to initialize Steam Audio."]
    #[doc = "\\param  params              Parameters to use for baking reflections data."]
    #[doc = "\\param  progressCallback    (Optional) This function will be called by Steam Audio to notify your application"]
    #[doc = "as the bake progresses. Use this to display a progress bar or some other indicator"]
    #[doc = "that the bake is running."]
    #[doc = "\\param  userData            (Optional) Pointer to arbitrary data that will be sent to the progress callback"]
    #[doc = "when Steam Audio calls it."]
    pub fn iplReflectionsBakerBake(
        context: IPLContext,
        params: *mut IPLReflectionsBakeParams,
        progressCallback: IPLProgressCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Cancels any running bakes of reflections data."]
    #[doc = ""]
    #[doc = "\\param  context             The context used to initialize Steam Audio."]
    pub fn iplReflectionsBakerCancelBake(context: IPLContext);
}
extern "C" {
    #[doc = " Bakes a single layer of pathing data in a probe batch."]
    #[doc = ""]
    #[doc = "Only one bake can be in progress at any point in time."]
    #[doc = ""]
    #[doc = "\\param  context             The context used to initialize Steam Audio."]
    #[doc = "\\param  params              Parameters to use for baking pathing data."]
    #[doc = "\\param  progressCallback    (Optional) This function will be called by Steam Audio to notify your application"]
    #[doc = "as the bake progresses. Use this to display a progress bar or some other indicator"]
    #[doc = "that the bake is running."]
    #[doc = "\\param  userData            (Optional) Pointer to arbitrary data that will be sent to the progress callback"]
    #[doc = "when Steam Audio calls it."]
    pub fn iplPathBakerBake(
        context: IPLContext,
        params: *mut IPLPathBakeParams,
        progressCallback: IPLProgressCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Cancels any running bakes of pathing data."]
    #[doc = ""]
    #[doc = "\\param  context             The context used to initialize Steam Audio."]
    pub fn iplPathBakerCancelBake(context: IPLContext);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IPLSource_t {
    _unused: [u8; 0],
}
pub type IPLSource = *mut _IPLSource_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IPLSimulator_t {
    _unused: [u8; 0],
}
pub type IPLSimulator = *mut _IPLSimulator_t;
#[repr(i32)]
#[doc = " Flags indicating which types of simulation should be enabled for a given \\c IPLSource."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IPLSimulationFlags {
    #[doc = " Enable direct simulation. This includes distance attenuation, air absorption, directivity, occlusion, and"]
    #[doc = "transmission."]
    IPL_SIMULATIONFLAGS_DIRECT = 1,
    #[doc = " Enable reflections simulation. This includes both real-time and baked simulation."]
    IPL_SIMULATIONFLAGS_REFLECTIONS = 2,
    #[doc = " Enable pathing simulation."]
    IPL_SIMULATIONFLAGS_PATHING = 4,
}
#[repr(i32)]
#[doc = " Flags indicating which types of direct simulation should be enabled for a given \\c IPLSource."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IPLDirectSimulationFlags {
    #[doc = " Enable distance attenuation calculations."]
    IPL_DIRECTSIMULATIONFLAGS_DISTANCEATTENUATION = 1,
    #[doc = " Enable air absorption calculations."]
    IPL_DIRECTSIMULATIONFLAGS_AIRABSORPTION = 2,
    #[doc = " Enable directivity calculations."]
    IPL_DIRECTSIMULATIONFLAGS_DIRECTIVITY = 4,
    #[doc = " Enable occlusion simulation."]
    IPL_DIRECTSIMULATIONFLAGS_OCCLUSION = 8,
    #[doc = " Enable transmission simulation. Requires occlusion to also be enabled."]
    IPL_DIRECTSIMULATIONFLAGS_TRANSMISSION = 16,
}
#[repr(i32)]
#[doc = " The types of distance attenuation that can be used."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IPLDistanceAttenuationModelType {
    #[doc = " The default distance attenuation model. This is an inverse distance falloff, with all sounds within 1 meter"]
    #[doc = "of the listener rendered without distance attenuation."]
    IPL_DISTANCEATTENUATIONTYPE_DEFAULT = 0,
    #[doc = " An inverse distance falloff. You can configure the minimum distance, within which distance attenuation is not"]
    #[doc = "applied."]
    IPL_DISTANCEATTENUATIONTYPE_INVERSEDISTANCE = 1,
    #[doc = " An arbitrary distance falloff function, defined by a callback function."]
    IPL_DISTANCEATTENUATIONTYPE_CALLBACK = 2,
}
#[repr(i32)]
#[doc = " The types of air absorption that can be used."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IPLAirAbsorptionModelType {
    #[doc = " The default air absorption model. This is an exponential falloff, with decay rates derived from physical"]
    #[doc = "properties of air."]
    IPL_AIRABSORPTIONTYPE_DEFAULT = 0,
    #[doc = " An exponential falloff. You can configure the decay rates for each frequency band."]
    IPL_AIRABSORPTIONTYPE_EXPONENTIAL = 1,
    #[doc = " An arbitrary air absorption model, defined by a callback function."]
    IPL_AIRABSORPTIONTYPE_CALLBACK = 2,
}
#[repr(i32)]
#[doc = " The different algorithms for simulating occlusion."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IPLOcclusionType {
    #[doc = " Raycast occlusion. A single ray is traced from the listener to the source. If the ray hits a solid object"]
    #[doc = "before it reaches the source, the source is considered occluded."]
    IPL_OCCLUSIONTYPE_RAYCAST = 0,
    #[doc = " A volumetric occlusion algorithm that can model partial occlusion. The source is modeled as a sphere with"]
    #[doc = "a configurable radius. Multiple points are sampled within the volume of this sphere. Rays are then traced"]
    #[doc = "from each sample point to both the source and the listener. A sample point is considered occluded if either"]
    #[doc = "of these two rays is occluded. The occlusion value for the source is calculated as the fraction of"]
    #[doc = "sample points that are unoccluded. This algorithm allows for smoother transitions in and out of occlusion."]
    IPL_OCCLUSIONTYPE_VOLUMETRIC = 1,
}
#[doc = " Callback for calculating how much attenuation should be applied to a sound based on its distance from the listener."]
#[doc = ""]
#[doc = "\\param  distance    The distance (in meters) between the source and the listener."]
#[doc = "\\param  userData    Pointer to the arbitrary data specified in the \\c IPLDistanceAttenuationModel."]
#[doc = ""]
#[doc = "\\return The distance attenuation to apply, between \\c 0 and \\c 1. \\c 0 = the sound is not audible, \\c 1 = the sound"]
#[doc = "is as loud as it would be if it were emitted from the listener's position."]
pub type IPLDistanceAttenuationCallback = ::std::option::Option<
    unsafe extern "C" fn(distance: IPLfloat32, userData: *mut ::std::os::raw::c_void) -> f32,
>;
#[doc = " Callback for calculating how much air absorption should be applied to a sound based on its distance from the"]
#[doc = "listener."]
#[doc = ""]
#[doc = "\\param  distance    The distance (in meters) between the source and the listener."]
#[doc = "\\param  band        Index of the frequency band for which to calculate air absorption. \\c 0 = low frequencies,"]
#[doc = "\\c 1 = middle frequencies, \\c 2 = high frequencies."]
#[doc = "\\param  userData    Pointer to the arbitrary data specified in the \\c IPLAirAbsorptionModel."]
#[doc = ""]
#[doc = "\\return The air absorption to apply, between \\c 0 and \\c 1. \\c 0 = sound in the frequency band \\c band is"]
#[doc = "not audible, \\c 1 = sound in the frequency band \\c band is not attenuated."]
pub type IPLAirAbsorptionCallback = ::std::option::Option<
    unsafe extern "C" fn(
        distance: IPLfloat32,
        band: IPLint32,
        userData: *mut ::std::os::raw::c_void,
    ) -> f32,
>;
#[doc = " Callback for calculating how much to attenuate a sound based on its directivity pattern and orientation in"]
#[doc = "world space."]
#[doc = ""]
#[doc = "\\param  direction   Unit vector (in world space) pointing forwards from the source. This is the direction"]
#[doc = "that the source is \"pointing towards\"."]
#[doc = "\\param  userData    Pointer to the arbitrary data specified in the \\c IPLDirectivity."]
#[doc = ""]
#[doc = "\\return The directivity value to apply, between \\c 0 and \\c 1. \\c 0 = the sound is not audible, \\c 1 = the sound"]
#[doc = "is as loud as it would be if it had a uniform (omnidirectional) directivity pattern."]
pub type IPLDirectivityCallback = ::std::option::Option<
    unsafe extern "C" fn(direction: IPLVector3, userData: *mut ::std::os::raw::c_void) -> f32,
>;
#[doc = " A distance attenuation model that can be used for modeling attenuation of sound over distance. Can be used"]
#[doc = "with both direct and indirect sound propagation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLDistanceAttenuationModel {
    #[doc = " The type of distance attenuation model to use."]
    pub type_: IPLDistanceAttenuationModelType,
    #[doc = " When \\c type is \\c IPL_DISTANCEATTENUATIONTYPE_INVERSEDISTANCE, no distance attenuation is applied to"]
    #[doc = "any sound whose distance from the listener is less than this value."]
    pub minDistance: IPLfloat32,
    #[doc = " When \\c type is \\c IPL_DISTANCEATTENUATIONTYPE_CALLBACK, this function will be called whenever Steam"]
    #[doc = "Audio needs to evaluate distance attenuation."]
    pub callback: IPLDistanceAttenuationCallback,
    #[doc = " Pointer to arbitrary data that will be provided to the \\c callback function whenever it is called."]
    #[doc = "May be \\c NULL."]
    pub userData: *mut ::std::os::raw::c_void,
    #[doc = " Set to \\c IPL_TRUE to indicate that the distance attenuation model defined by the \\c callback function"]
    #[doc = "has changed since the last time simulation was run. For example, the callback may be evaluating a"]
    #[doc = "curve defined in a GUI. If the user is editing the curve in real-time, set this to \\c IPL_TRUE whenever"]
    #[doc = "the curve changes, so Steam Audio can update simulation results to match."]
    pub dirty: IPLbool,
}
#[doc = " An air absorption model that can be used for modeling frequency-dependent attenuation of sound over"]
#[doc = "distance."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLAirAbsorptionModel {
    #[doc = " The type of air absorption model to use."]
    pub type_: IPLAirAbsorptionModelType,
    #[doc = " The exponential falloff coefficients to use when \\c type is \\c IPL_AIRABSORPTIONTYPE_EXPONENTIAL."]
    pub coefficients: [IPLfloat32; 3usize],
    #[doc = " When \\c type is \\c IPL_AIRABSORPTIONTYPE_CALLBACK, this function will be called whenever Steam"]
    #[doc = "Audio needs to evaluate air absorption."]
    pub callback: IPLAirAbsorptionCallback,
    #[doc = " Pointer to arbitrary data that will be provided to the \\c callback function whenever it is called."]
    #[doc = "May be \\c NULL."]
    pub userData: *mut ::std::os::raw::c_void,
    #[doc = " Set to \\c IPL_TRUE to indicate that the air absorption model defined by the \\c callback function"]
    #[doc = "has changed since the last time simulation was run. For example, the callback may be evaluating a set of"]
    #[doc = "curves defined in a GUI. If the user is editing the curves in real-time, set this to \\c IPL_TRUE whenever"]
    #[doc = "the curves change, so Steam Audio can update simulation results to match."]
    pub dirty: IPLbool,
}
#[doc = " A directivity pattern that can be used to model changes in sound intensity as a function of the source's"]
#[doc = "orientation. Can be used with both direct and indirect sound propagation."]
#[doc = ""]
#[doc = "The default directivity model is a weighted dipole. This is a linear blend between an omnidirectional"]
#[doc = "source (which emits sound with equal intensity in all directions), and a dipole oriented along the z-axis"]
#[doc = "in the source's coordinate system (which focuses sound along the +z and -z axes). A callback function"]
#[doc = "can be specified to implement any other arbitrary directivity pattern."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLDirectivity {
    #[doc = " How much of the dipole to blend into the directivity pattern. \\c 0 = pure omnidirectional, \\c 1 = pure"]
    #[doc = "dipole. \\c 0.5f results in a cardioid directivity pattern."]
    pub dipoleWeight: IPLfloat32,
    #[doc = " How \"sharp\" the dipole is. Higher values result in sound being focused within a narrower range of"]
    #[doc = "directions."]
    pub dipolePower: IPLfloat32,
    #[doc = " If non \\c NULL, this function will be called whenever Steam Audio needs to evaluate a directivity"]
    #[doc = "pattern."]
    pub callback: IPLDirectivityCallback,
    #[doc = " Pointer to arbitrary data that will be provided to the \\c callback function whenever it is called."]
    #[doc = "May be \\c NULL."]
    pub userData: *mut ::std::os::raw::c_void,
}
#[doc = " Settings used to create a simulator."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLSimulationSettings {
    #[doc = " The types of simulation that this simulator will be used for."]
    pub flags: IPLSimulationFlags,
    #[doc = " The type of scene that will be used for simulations via \\c iplSimulatorSetScene. The scene type"]
    #[doc = "cannot change during the lifetime of a simulator object."]
    pub sceneType: IPLSceneType,
    #[doc = " The type of reflections effect that will be used to render the results of reflections simulation."]
    #[doc = "The reflections effect type cannot change during the lifetime of a simulator object."]
    pub reflectionType: IPLReflectionEffectType,
    #[doc = " The maximum number of point samples to consider when calculating occlusion using the"]
    #[doc = "volumetric occlusion algorithm. Different sources can use different numbers of samples, and the"]
    #[doc = "number of samples can change between simulation runs, but this is the maximum value. Increasing"]
    #[doc = "this value results in smoother occlusion transitions, at the cost of increased CPU usage."]
    pub maxNumOcclusionSamples: IPLint32,
    #[doc = " The maximum number of rays to trace from the listener when simulating reflections. You can use"]
    #[doc = "different numbers of rays between simulation runs, but this is the maximum value. Increasing"]
    #[doc = "this value results in more accurate reflections, at the cost of increased CPU usage."]
    pub maxNumRays: IPLint32,
    #[doc = " The number of directions to sample when generating diffusely reflected rays. Increasing this"]
    #[doc = "value may increase the accuracy of diffuse reflections."]
    pub numDiffuseSamples: IPLint32,
    #[doc = " The maximum length (in seconds) of impulse responses generated by reflection simulations. You"]
    #[doc = "can change this value betweeen simulation runs, but this is the maximum value. Increasing this"]
    #[doc = "value results in longer, more accurate reverb tails, at the cost of increased CPU and memory usage."]
    pub maxDuration: IPLfloat32,
    #[doc = " The maximum Ambisonic order of impulse responses generated by reflection simulations. You can"]
    #[doc = "change this value between simulation runs, but this is the maximum value. Increasing this"]
    #[doc = "value results in more accurate directional variations in the impulse responses, at the cost of"]
    #[doc = "increased CPU and memory usage."]
    pub maxOrder: IPLint32,
    #[doc = " The maximum number of sources for which reflection simulations will be run at any given time."]
    pub maxNumSources: IPLint32,
    #[doc = " The number of threads used for real-time reflection simulations."]
    pub numThreads: IPLint32,
    #[doc = " If using custom ray tracer callbacks, this the number of rays that will be passed to the callbacks"]
    #[doc = "every time rays need to be traced."]
    pub rayBatchSize: IPLint32,
    #[doc = " The number of point samples to consider when calculating probe-to-probe visibility for pathing"]
    #[doc = "simulations. Baked paths may end up being occluded by dynamic objects, in which case you can configure"]
    #[doc = "the simulator to look for alternate paths in real time. This process will involve checking visibility"]
    #[doc = "between probes."]
    pub numVisSamples: IPLint32,
    #[doc = " The sampling rate (in Hz) used for audio processing."]
    pub samplingRate: IPLint32,
    #[doc = " The size (in samples) of the audio buffers used for audio processing."]
    pub frameSize: IPLint32,
    #[doc = " The OpenCL device being used. Only necessary if \\sceneType is \\c IPL_SCENETYPE_RADEONRAYS, or \\c reflectionType"]
    #[doc = "is \\c IPL_REFLECTIONEFFECTTYPE_TAN."]
    pub openCLDevice: IPLOpenCLDevice,
    #[doc = " The Radeon Rays device being used. Only necessary if \\sceneType is \\c IPL_SCENETYPE_RADEONRAYS."]
    pub radeonRaysDevice: IPLRadeonRaysDevice,
    #[doc = " The TrueAudio Next device being used. Only necessary if \\c reflectionType is \\c IPL_REFLECTIONEFFECTTYPE_TAN."]
    pub tanDevice: IPLTrueAudioNextDevice,
}
#[doc = " Settings used to create a source."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLSourceSettings {
    #[doc = " The types of simulation that may be run for this source."]
    pub flags: IPLSimulationFlags,
}
#[doc = " Simulation parameters for a source."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLSimulationInputs {
    #[doc = " The types of simulation to run for this source."]
    pub flags: IPLSimulationFlags,
    #[doc = " The types of direct simulation to run for this source."]
    pub directFlags: IPLDirectSimulationFlags,
    #[doc = " The position and orientation of this source."]
    pub source: IPLCoordinateSpace3,
    #[doc = " The distance attenuation model to use for this source."]
    pub distanceAttenuationModel: IPLDistanceAttenuationModel,
    #[doc = " The air absorption model to use for this source."]
    pub airAbsorptionModel: IPLAirAbsorptionModel,
    #[doc = " The directivity pattern to use for this source."]
    pub directivity: IPLDirectivity,
    #[doc = " The occlusion algorithm to use for this source."]
    pub occlusionType: IPLOcclusionType,
    #[doc = " If using volumetric occlusion, the source is modeled as a sphere with this radius."]
    pub occlusionRadius: IPLfloat32,
    #[doc = " If using volumetric occlusion, this is the number of point samples to consider when"]
    #[doc = "tracing rays. This value can change between simulation runs."]
    pub numOcclusionSamples: IPLint32,
    #[doc = " If using parametric or hybrid reverb for rendering reflections, the reverb decay times"]
    #[doc = "for each frequency band are scaled by these values. Set to \\c {1.0f, 1.0f, 1.0f} to use"]
    #[doc = "the simulated values without modification."]
    pub reverbScale: [IPLfloat32; 3usize],
    #[doc = " If using hybrid reverb for rendering reflections, this is the length (in seconds) of"]
    #[doc = "impulse response to use for convolution reverb. The rest of the impulse response will"]
    #[doc = "be used for parametric reverb estimation only. Increasing this value results in more"]
    #[doc = "accurate reflections, at the cost of increased CPU usage."]
    pub hybridReverbTransitionTime: IPLfloat32,
    #[doc = " If using hybrid reverb for rendering reflections, this is the amount of overlap between"]
    #[doc = "the convolution and parametric parts. To ensure smooth transitions from the early"]
    #[doc = "convolution part to the late parametric part, the two are cross-faded towards the end of"]
    #[doc = "the convolution part. For example, if \\c hybridReverbTransitionTime is \\c 1.0f, and"]
    #[doc = "\\c hybridReverbOverlapPercent is \\c 0.25f, then the first 0.75 seconds are pure convolution,"]
    #[doc = "the next 0.25 seconds are a blend between convolution and parametric, and the portion of"]
    #[doc = "the tail beyond 1.0 second is pure parametric."]
    pub hybridReverbOverlapPercent: IPLfloat32,
    #[doc = " If \\c IPL_TRUE, this source will used baked data for reflections simulation."]
    pub baked: IPLbool,
    #[doc = " The identifier used to specify which layer of baked data to use for simulating reflections"]
    #[doc = "for this source."]
    pub bakedDataIdentifier: IPLBakedDataIdentifier,
    #[doc = " The probe batch within which to find paths from this source to the listener."]
    pub pathingProbes: IPLProbeBatch,
    #[doc = " When testing for mutual visibility between a pair of probes, each probe is treated as a sphere of"]
    #[doc = "this radius (in meters), and point samples are generated within this sphere."]
    pub visRadius: IPLfloat32,
    #[doc = " When tracing rays to test for mutual visibility between a pair of probes, the fraction of rays that"]
    #[doc = "are unoccluded must be greater than this threshold for the pair of probes to be considered"]
    #[doc = "mutually visible."]
    pub visThreshold: IPLfloat32,
    #[doc = " If the distance between two probes is greater than this value, the probes are not considered mutually"]
    #[doc = "visible. Increasing this value can result in simpler paths, at the cost of increased CPU usage."]
    pub visRange: IPLfloat32,
    #[doc = " If simulating pathing, this is the Ambisonic order used for representing path directionality. Higher"]
    #[doc = "values result in more precise spatialization of paths, at the cost of increased CPU usage."]
    pub pathingOrder: IPLint32,
    #[doc = " If \\c IPL_TRUE, baked paths are tested for visibility. This is useful if your scene has dynamic"]
    #[doc = "objects that might occlude baked paths."]
    pub enableValidation: IPLbool,
    #[doc = " If \\c IPL_TRUE, and \\c enableValidation is \\c IPL_TRUE, then if a baked path is occluded by dynamic"]
    #[doc = "geometry, path finding is re-run in real-time to find alternate paths that take into account the"]
    #[doc = "dynamic geometry."]
    pub findAlternatePaths: IPLbool,
}
#[doc = " Simulation parameters that are not specific to any source."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLSimulationSharedInputs {
    #[doc = " The position and orientation of the listener."]
    pub listener: IPLCoordinateSpace3,
    #[doc = " The number of rays to trace from the listener. Increasing this value results in more accurate"]
    #[doc = "reflections, at the cost of increased CPU usage."]
    pub numRays: IPLint32,
    #[doc = " The number of times each ray traced from the listener is reflected when it encounters a solid"]
    #[doc = "object. Increasing this value results in longer, more accurate reverb tails, at the cost of"]
    #[doc = "increased CPU usage during simulation."]
    pub numBounces: IPLint32,
    #[doc = " The duration (in seconds) of the impulse responses generated when simulating reflections."]
    #[doc = "Increasing this value results in longer, more accurate reverb tails, at the cost of increased"]
    #[doc = "CPU usage during audio processing."]
    pub duration: IPLfloat32,
    #[doc = " The Ambisonic order of the impulse responses generated when simulating reflections. Increasing"]
    #[doc = "this value results in more accurate directional variation of reflected sound, at the cost"]
    #[doc = "of increased CPU usage during audio processing."]
    pub order: IPLint32,
    #[doc = " When calculating how much sound energy reaches a surface directly from a source, any source that is"]
    #[doc = "closer than \\c irradianceMinDistance to the surface is assumed to be at a distance of"]
    #[doc = "\\c irradianceMinDistance, for the purposes of energy calculations."]
    pub irradianceMinDistance: IPLfloat32,
}
#[doc = " Simulation results for a source."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPLSimulationOutputs {
    #[doc = " Direct path simulation results."]
    pub direct: IPLDirectEffectParams,
    #[doc = " Reflection simulation results."]
    pub reflections: IPLReflectionEffectParams,
    #[doc = " Pathing simulation results."]
    pub pathing: IPLPathEffectParams,
}
extern "C" {
    #[doc = " Creates a simulator."]
    #[doc = ""]
    #[doc = "\\param  context     The context used to initialize Steam Audio."]
    #[doc = "\\param  settings    The settings to use when creating the simulator."]
    #[doc = "\\param  simulator   [out] The created simulator."]
    #[doc = ""]
    #[doc = "\\return Status code indicating whether or not the operation succeeded."]
    pub fn iplSimulatorCreate(
        context: IPLContext,
        settings: *mut IPLSimulationSettings,
        simulator: *mut IPLSimulator,
    ) -> IPLerror;
}
extern "C" {
    #[doc = " Retains an additional reference to a simulator."]
    #[doc = ""]
    #[doc = "\\param  simulator   The simulator to retain a reference to."]
    #[doc = ""]
    #[doc = "\\return The additional reference to the simulator."]
    pub fn iplSimulatorRetain(simulator: IPLSimulator) -> IPLSimulator;
}
extern "C" {
    #[doc = " Releases a reference to a simulator."]
    #[doc = ""]
    #[doc = "\\param  simulator   The simulator to release a reference to."]
    pub fn iplSimulatorRelease(simulator: *mut IPLSimulator);
}
extern "C" {
    #[doc = " Specifies the scene within which all subsequent simulations should be run."]
    #[doc = ""]
    #[doc = "Call \\c iplSimulatorCommit after calling this function for the changes to take effect."]
    #[doc = ""]
    #[doc = "This function cannot be called while any simulation is running."]
    #[doc = ""]
    #[doc = "\\param  simulator   The simulator being used."]
    #[doc = "\\param  scene       The scene to use for simulations."]
    pub fn iplSimulatorSetScene(simulator: IPLSimulator, scene: IPLScene);
}
extern "C" {
    #[doc = " Adds a probe batch for use in subsequent simulations. Sources that require baked data can then use the"]
    #[doc = "data contained in the specified probe batch."]
    #[doc = ""]
    #[doc = "Call \\c iplSimulatorCommit after calling this function for the changes to take effect."]
    #[doc = ""]
    #[doc = "This function cannot be called while any simulation is running."]
    #[doc = ""]
    #[doc = "\\param  probeBatch  The probe batch to add."]
    #[doc = "\\param  simulator   The simulator being used."]
    pub fn iplSimulatorAddProbeBatch(simulator: IPLSimulator, probeBatch: IPLProbeBatch);
}
extern "C" {
    #[doc = " Removed a probe batch from use in subsequent simulations. Sources that require baked data will then stop using the"]
    #[doc = "data contained in the specified probe batch."]
    #[doc = ""]
    #[doc = "Call \\c iplSimulatorCommit after calling this function for the changes to take effect."]
    #[doc = ""]
    #[doc = "This function cannot be called while any simulation is running."]
    #[doc = ""]
    #[doc = "\\param  probeBatch  The probe batch to remove."]
    #[doc = "\\param  simulator   The simulator being used."]
    pub fn iplSimulatorRemoveProbeBatch(simulator: IPLSimulator, probeBatch: IPLProbeBatch);
}
extern "C" {
    #[doc = " Specifies simulation parameters that are not associated with any particular source."]
    #[doc = ""]
    #[doc = "\\param  simulator       The simulator being used."]
    #[doc = "\\param  flags           The types of simulation for which to specify shared inputs. If, for example, direct"]
    #[doc = "and reflections simulations are being run on separate threads, you can call this"]
    #[doc = "function on the direct simulation thread with \\c IPL_SIMULATIONFLAGS_DIRECT, and on the"]
    #[doc = "reflections simulation thread with \\c IPL_SIMULATIONFLAGS_REFLECTIONS, without requiring"]
    #[doc = "any synchronization between the calls."]
    #[doc = "\\param  sharedInputs    The shared input parameters to set."]
    pub fn iplSimulatorSetSharedInputs(
        simulator: IPLSimulator,
        flags: IPLSimulationFlags,
        sharedInputs: *mut IPLSimulationSharedInputs,
    );
}
extern "C" {
    #[doc = " Commits changes to the scene or probe batches used for simulation."]
    #[doc = ""]
    #[doc = "Call this function after calling \\c iplSimulatorSetScene, \\c iplSimulatorAddProbeBatch, or"]
    #[doc = "\\c iplSimulatorRemoveProbeBatch for the changes to take effect."]
    #[doc = ""]
    #[doc = "This function cannot be called while any simulation is running."]
    #[doc = ""]
    #[doc = "\\param  simulator   The simulator being used."]
    pub fn iplSimulatorCommit(simulator: IPLSimulator);
}
extern "C" {
    #[doc = " Runs a direct simulation for all sources added to the simulator. This may include distance attenuation,"]
    #[doc = "air absorption, directivity, occlusion, and transmission."]
    #[doc = ""]
    #[doc = "This function should not be called from the audio processing thread if occlusion and/or transmission"]
    #[doc = "are enabled."]
    #[doc = ""]
    #[doc = "\\param  simulator   The simulator being used."]
    pub fn iplSimulatorRunDirect(simulator: IPLSimulator);
}
extern "C" {
    #[doc = " Runs a reflections simulation for all sources added to the simulator."]
    #[doc = ""]
    #[doc = "This function can be CPU intensive, and should be called from a separate thread in order to not"]
    #[doc = "block either the audio processing thread or the game's main update thread."]
    #[doc = ""]
    #[doc = "\\param  simulator   The simulator being used."]
    pub fn iplSimulatorRunReflections(simulator: IPLSimulator);
}
extern "C" {
    #[doc = " Runs a pathing simulation for all sources added to the simulator."]
    #[doc = ""]
    #[doc = "This function can be CPU intensive, and should be called from a separate thread in order to not"]
    #[doc = "block either the audio processing thread or the game's main update thread."]
    #[doc = ""]
    #[doc = "\\param  simulator   The simulator being used."]
    pub fn iplSimulatorRunPathing(simulator: IPLSimulator);
}
extern "C" {
    #[doc = " Creates a simulation source."]
    #[doc = ""]
    #[doc = "\\param  simulator   The simulator with which this source will be used."]
    #[doc = "\\param  settings    The settings to use for creating the source."]
    #[doc = "\\param  source      [out] The created source."]
    #[doc = ""]
    #[doc = "\\return Status code indicating whether or not the operation succeeded."]
    pub fn iplSourceCreate(
        simulator: IPLSimulator,
        settings: *mut IPLSourceSettings,
        source: *mut IPLSource,
    ) -> IPLerror;
}
extern "C" {
    #[doc = " Retains an additional reference to a source."]
    #[doc = ""]
    #[doc = "\\param  source  The source to retain a reference to."]
    #[doc = ""]
    #[doc = "\\return The additional reference to the source."]
    pub fn iplSourceRetain(source: IPLSource) -> IPLSource;
}
extern "C" {
    #[doc = " Releases a reference to a source."]
    #[doc = ""]
    #[doc = "\\param  source  The source to release a reference to."]
    pub fn iplSourceRelease(source: *mut IPLSource);
}
extern "C" {
    #[doc = " Adds a source to the set of sources processed by a simulator in subsequent simulations."]
    #[doc = ""]
    #[doc = "\\param  simulator   The simulator being used."]
    #[doc = "\\param  source      The source to add."]
    pub fn iplSourceAdd(source: IPLSource, simulator: IPLSimulator);
}
extern "C" {
    #[doc = " Removes a source from the set of sources processed by a simulator in subsequent simulations."]
    #[doc = ""]
    #[doc = "\\param  simulator   The simulator being used."]
    #[doc = "\\param  source      The source to remove."]
    pub fn iplSourceRemove(source: IPLSource, simulator: IPLSimulator);
}
extern "C" {
    #[doc = " Specifies simulation parameters for a source."]
    #[doc = ""]
    #[doc = "\\param  source  The source to specify parameters for."]
    #[doc = "\\param  flags   The types of simulation for which to specify inputs. If, for example, direct"]
    #[doc = "and reflections simulations are being run on separate threads, you can call this"]
    #[doc = "function on the direct simulation thread with \\c IPL_SIMULATIONFLAGS_DIRECT, and on the"]
    #[doc = "reflections simulation thread with \\c IPL_SIMULATIONFLAGS_REFLECTIONS, without requiring"]
    #[doc = "any synchronization between the calls."]
    #[doc = "\\param  inputs  The input parameters to set."]
    pub fn iplSourceSetInputs(
        source: IPLSource,
        flags: IPLSimulationFlags,
        inputs: *mut IPLSimulationInputs,
    );
}
extern "C" {
    #[doc = " Retrieves simulation results for a source."]
    #[doc = ""]
    #[doc = "\\param  source  The source to retrieve results for."]
    #[doc = "\\param  flags   The types of simulation for which to retrieve results."]
    #[doc = "\\param  outputs [out] The simulation results."]
    pub fn iplSourceGetOutputs(
        source: IPLSource,
        flags: IPLSimulationFlags,
        outputs: *mut IPLSimulationOutputs,
    );
}
extern "C" {
    #[doc = " Calculates the distance attenuation between a source and a listener."]
    #[doc = ""]
    #[doc = "\\param  context     The context used to initialize Steam Audio."]
    #[doc = "\\param  source      The position of the source."]
    #[doc = "\\param  listener    The position of the listener."]
    #[doc = "\\param  model       The distance attenuation model to use."]
    #[doc = ""]
    #[doc = "\\return The distance attenuation to apply, between \\c 0 and \\c 1."]
    pub fn iplDistanceAttenuationCalculate(
        context: IPLContext,
        source: IPLVector3,
        listener: IPLVector3,
        model: *mut IPLDistanceAttenuationModel,
    ) -> IPLfloat32;
}
extern "C" {
    #[doc = " Calculates the air absorption coefficients between a source and a listener."]
    #[doc = ""]
    #[doc = "\\param  context         The context used to initialize Steam Audio."]
    #[doc = "\\param  source          The position of the source."]
    #[doc = "\\param  listener        The position of the listener."]
    #[doc = "\\param  model           The air absorption model to use."]
    #[doc = "\\param  airAbsorption   [out] The 3-band air absorption coefficients, each between \\c 0 and \\c 1."]
    pub fn iplAirAbsorptionCalculate(
        context: IPLContext,
        source: IPLVector3,
        listener: IPLVector3,
        model: *mut IPLAirAbsorptionModel,
        airAbsorption: *mut IPLfloat32,
    );
}
extern "C" {
    #[doc = " Calculates the attenuation of a source due to its directivity pattern and orientation relative to a listener."]
    #[doc = ""]
    #[doc = "\\param  context     The context used to initialize Steam Audio."]
    #[doc = "\\param  source      The position and orientation of the source."]
    #[doc = "\\param  listener    The position of the listener."]
    #[doc = "\\param  model       The directivity pattern to use."]
    #[doc = ""]
    #[doc = "\\return The directivity value to apply, between \\c 0 and \\c 1."]
    pub fn iplDirectivityCalculate(
        context: IPLContext,
        source: IPLCoordinateSpace3,
        listener: IPLVector3,
        model: *mut IPLDirectivity,
    ) -> IPLfloat32;
}
